<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  
  

  


  <head>
    <title>
      A2QuickStartGuide.tex in trunk/Docs/ShortCourse
     – OberonRu
    </title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <!--[if IE]><script type="text/javascript">window.location.hash = window.location.hash;</script><![endif]-->
        <link rel="search" href="/oberonru/search" />
        <link rel="help" href="/oberonru/wiki/TracGuide" />
        <link rel="alternate" href="/oberonru/browser/trunk/Docs/ShortCourse/A2QuickStartGuide.tex?format=txt" type="text/plain" title="Plain Text" /><link rel="alternate" href="/oberonru/export/229/trunk/Docs/ShortCourse/A2QuickStartGuide.tex" type="text/x-tex; charset=utf-8" title="Original Format" />
        <link rel="start" href="/oberonru/wiki" />
        <link rel="stylesheet" href="/oberonru/chrome/common/css/trac.css" type="text/css" /><link rel="stylesheet" href="/oberonru/chrome/common/css/code.css" type="text/css" /><link rel="stylesheet" href="/oberonru/chrome/common/css/browser.css" type="text/css" />
        <link rel="shortcut icon" href="/oberonru/chrome/common/trac.ico" type="image/x-icon" />
        <link rel="icon" href="/oberonru/chrome/common/trac.ico" type="image/x-icon" />
      <link type="application/opensearchdescription+xml" rel="search" href="/oberonru/search/opensearch" title="Search OberonRu" />
    <script type="text/javascript" src="/oberonru/chrome/common/js/jquery.js"></script><script type="text/javascript" src="/oberonru/chrome/common/js/babel.js"></script><script type="text/javascript" src="/oberonru/chrome/common/js/trac.js"></script><script type="text/javascript" src="/oberonru/chrome/common/js/search.js"></script>
    <!--[if lt IE 7]>
    <script type="text/javascript" src="/oberonru/chrome/common/js/ie_pre7_hacks.js"></script>
    <![endif]-->
    <script type="text/javascript" src="/oberonru/chrome/common/js/folding.js"></script>
    <script type="text/javascript">
      jQuery(document).ready(function($) {
        $(".trac-toggledeleted").show().click(function() {
                  $(this).siblings().find(".trac-deleted").toggle();
                  return false;
        }).click();
        $("#jumploc input").hide();
        $("#jumploc select").change(function () {
          this.parentNode.parentNode.submit();
        });
          $('#preview table.code').enableCollapsibleColumns($('#preview table.code thead th.content'));
      });
    </script>
    <style type="text/css">
/* ---------------------------------------------------
=col
------------------------------------------------------ */
/* span one col */
.col {
        /* avoid rounding errors */
        width: 40%;
        float: left;
        padding: .375em  .375em .5em .375em;
}
.user-col {
        float: right;
        text-align: right;
}
.col a:link,
.col a:visited {
        color: #E3EFFC;
        border-bottom: 1px solid #E3EFFC;
}
.col a:hover {
        border-bottom: none;
        background: transparent;
}
/* ---------------------------------------------------
=header
------------------------------------------------------ */
#top-bar-w {
        margin-left:-10px;
        margin-right:-10px;
        padding-left:10px;
        padding-right:10px;
        background: #2E4B73;
        color: #5375A6;
        font-family: Verdana, sans-serif;
        font-size: 9px;
        font-style: normal;
        line-height: normal;
        font-weight: normal;
        font-variant: normal;
        width:100%;
}
/* ---------------------------------------------------
=utilities
----------------------------------------------------- */
.cut {clear: both; height: 1px; overflow: hidden;}
.hidden { display: none;}
.inline { display: inline; }
.clear-float  {
        /* clear floated children */
        overflow: hidden;
        /* IE fix see:
        http://www.positioniseverything.net/easyclearing.html
        */
        _height: 1%;
}
    </style>
  </head>
  <body>
    <div id="siteheader">
      <div id="top-bar-w">
	<div class="col">
	  <a href="http://www.assembla.com"><b>Assembla home</b></a> | <a href="https://www.assembla.com/spaces/show/oberonru">Assembla project page</a>
	</div>
	<div class="col user-col">
	  <div id="user-box">
            <a href="http://www.assembla.com/user/start" rel="nofollow">My Start Page</a>
            <!-- /user-box -->
	  </div>
	</div>
	<!-- clear float, the old skool way -->
	<div class="cut"> </div>
	<!-- /top-bar-w -->
      </div>
    </div>
    <div id="banner">
      <div id="header">
        <h1><a href="https://www.assembla.com/spaces/show/oberonru">OberonRu</a></h1>
      </div>
      <form id="search" action="/oberonru/search" method="get">
        <div>
          <label for="proj-search">Search:</label>
          <input type="text" id="proj-search" name="q" size="18" value="" />
          <input type="submit" value="Search" />
        </div>
      </form>
      <div id="metanav" class="nav">
    <ul>
      <li class="first"><a href="/oberonru/login">Login</a></li><li><a href="/oberonru/prefs">Preferences</a></li><li><a href="/oberonru/wiki/TracGuide">Help/Guide</a></li><li class="last"><a href="/oberonru/about">About Trac</a></li>
    </ul>
  </div>
    </div>
    <div id="mainnav" class="nav">
    <ul>
      <li class="first"><a href="/oberonru/wiki">Wiki</a></li><li><a href="/oberonru/timeline">Timeline</a></li><li><a href="/oberonru/roadmap">Roadmap</a></li><li class="active"><a href="/oberonru/browser">Browse Source</a></li><li><a href="/oberonru/report">View Tickets</a></li><li class="last"><a href="/oberonru/search">Search</a></li>
    </ul>
  </div>
    <div id="main">
      <div id="ctxtnav" class="nav">
        <h2>Context Navigation</h2>
          <ul>
              <li class="first"><a href="/oberonru/browser/trunk/Docs/ShortCourse/A2QuickStartGuide.tex?annotate=blame" title="Annotate each line with the last changed revision (this can be time consuming...)">Blame</a></li><li class="last"><a href="/oberonru/log/trunk/Docs/ShortCourse/A2QuickStartGuide.tex">Revision Log</a></li>
          </ul>
        <hr />
      </div>
    <div id="content" class="browser">
          <h1>
<a class="pathentry first" href="/oberonru/browser?order=name" title="Go to repository root">source:</a>
<a class="pathentry" href="/oberonru/browser/trunk?order=name" title="View trunk">trunk</a><span class="pathentry sep">/</span><a class="pathentry" href="/oberonru/browser/trunk/Docs?order=name" title="View Docs">Docs</a><span class="pathentry sep">/</span><a class="pathentry" href="/oberonru/browser/trunk/Docs/ShortCourse?order=name" title="View ShortCourse">ShortCourse</a><span class="pathentry sep">/</span><a class="pathentry" href="/oberonru/browser/trunk/Docs/ShortCourse/A2QuickStartGuide.tex?order=name" title="View A2QuickStartGuide.tex">A2QuickStartGuide.tex</a>
<span class="pathentry sep">@</span>
  <a class="pathentry" href="/oberonru/changeset/229" title="View changeset 229">229</a>
<br style="clear: both" />
</h1>
        <div id="jumprev">
          <form action="" method="get">
            <div>
              <label for="rev">
                View revision:</label>
              <input type="text" id="rev" name="rev" size="6" />
            </div>
          </form>
        </div>
        <div id="jumploc">
          <form action="" method="get">
            <div class="buttons">
              <label for="preselected">Visit:</label>
              <select id="preselected" name="preselected">
                <option selected="selected"></option>
                <optgroup label="branches">
                  <option value="/oberonru/browser/trunk">trunk</option>
                </optgroup>
              </select>
              <input type="submit" value="Go!" title="Jump to the chosen preselected path" />
            </div>
          </form>
        </div>
      <table id="info" summary="Revision info">
        <tr>
          <th scope="col">Revision <a href="/oberonru/changeset/96">96</a>,
            <span title="52338 bytes">51.1 KB</span>
            checked in by lit-uriy, <a class="timeline" href="/oberonru/timeline?from=2009-06-12T18%3A44%3A06Z&amp;precision=second" title="2009-06-12T18:44:06Z in Timeline">6 years</a> ago
            (<a href="/oberonru/changeset/96/trunk/Docs/ShortCourse/A2QuickStartGuide.tex">diff</a>)</th>
        </tr>
        <tr>
          <td class="message searchable">
              <p>
Документация:<br />
Закинул всю документацию из официального хранилища А2<br />
(Появилась документация на Сборщик Мусора-RTGC!).<br />
</p>
          </td>
        </tr>
      </table>
      <div id="preview" class="searchable">
        
  <table class="code"><thead><tr><th class="lineno" title="Line numbers">Line</th><th class="content"> </th></tr></thead><tbody><tr><th id="L1"><a href="#L1">1</a></th><td>\documentclass[a4paper,11pt]{article}</td></tr><tr><th id="L2"><a href="#L2">2</a></th><td>\usepackage{color}</td></tr><tr><th id="L3"><a href="#L3">3</a></th><td>\usepackage{hyperref}</td></tr><tr><th id="L4"><a href="#L4">4</a></th><td>% listings: http://mirror.switch.ch/ftp/mirror/tex/help/Catalogue/entries/listings.html</td></tr><tr><th id="L5"><a href="#L5">5</a></th><td>\usepackage{listings}</td></tr><tr><th id="L6"><a href="#L6">6</a></th><td>\usepackage{xspace}</td></tr><tr><th id="L7"><a href="#L7">7</a></th><td>% longtable: http://mirror.switch.ch/ftp/mirror/tex/help/Catalogue/entries/longtable.html</td></tr><tr><th id="L8"><a href="#L8">8</a></th><td>\usepackage{longtable}</td></tr><tr><th id="L9"><a href="#L9">9</a></th><td>\usepackage{array}</td></tr><tr><th id="L10"><a href="#L10">10</a></th><td>% --------------------------------- page layout --------------------------------------</td></tr><tr><th id="L11"><a href="#L11">11</a></th><td>\pagestyle{headings}</td></tr><tr><th id="L12"><a href="#L12">12</a></th><td>% other font styles:</td></tr><tr><th id="L13"><a href="#L13">13</a></th><td>%\usepackage[math]{iwona} % iwona, kurier</td></tr><tr><th id="L14"><a href="#L14">14</a></th><td>%\usepackage{cmbright}</td></tr><tr><th id="L15"><a href="#L15">15</a></th><td></td></tr><tr><th id="L16"><a href="#L16">16</a></th><td>\oddsidemargin -0 cm</td></tr><tr><th id="L17"><a href="#L17">17</a></th><td>\evensidemargin 0 cm</td></tr><tr><th id="L18"><a href="#L18">18</a></th><td>%\topmargin -1.5cm</td></tr><tr><th id="L19"><a href="#L19">19</a></th><td>\textwidth 16   cm</td></tr><tr><th id="L20"><a href="#L20">20</a></th><td>%\textheight 25 cm</td></tr><tr><th id="L21"><a href="#L21">21</a></th><td></td></tr><tr><th id="L22"><a href="#L22">22</a></th><td>\parskip 5pt</td></tr><tr><th id="L23"><a href="#L23">23</a></th><td>\parindent 0cm</td></tr><tr><th id="L24"><a href="#L24">24</a></th><td></td></tr><tr><th id="L25"><a href="#L25">25</a></th><td>% --------------------------------- colors --------------------------------------</td></tr><tr><th id="L26"><a href="#L26">26</a></th><td>\definecolor{lightgrey}{rgb}{0.5,0.5,0.5}</td></tr><tr><th id="L27"><a href="#L27">27</a></th><td>\definecolor{darkgrey}{rgb}{0.4,0.4,0.4}</td></tr><tr><th id="L28"><a href="#L28">28</a></th><td></td></tr><tr><th id="L29"><a href="#L29">29</a></th><td>% --------------------------------- own commands --------------------------------------</td></tr><tr><th id="L30"><a href="#L30">30</a></th><td>\newcommand{\changefont}[3]{\fontfamily{#1}\fontseries{#2}\fontshape{#3}\selectfont}</td></tr><tr><th id="L31"><a href="#L31">31</a></th><td></td></tr><tr><th id="L32"><a href="#L32">32</a></th><td>\newcommand{\progfont}{\changefont{pcr}{m}{n}}</td></tr><tr><th id="L33"><a href="#L33">33</a></th><td>\newcommand{\kwfont}{\changefont{pcr}{b}{n}}</td></tr><tr><th id="L34"><a href="#L34">34</a></th><td>\renewcommand{\lstlistingname}{Fig.}</td></tr><tr><th id="L35"><a href="#L35">35</a></th><td>\newcommand{\todo}[1]{\setlength{\fboxrule}{2pt}\fcolorbox{red}{yellow}{\begin{minipage}{\textwidth} \color{blue}$todo:$ #1 \end{minipage}}}</td></tr><tr><th id="L36"><a href="#L36">36</a></th><td></td></tr><tr><th id="L37"><a href="#L37">37</a></th><td>\newcommand{\pc}[1]{\makebox{\progfont #1}}</td></tr><tr><th id="L38"><a href="#L38">38</a></th><td>\newcommand{\kw}[1]{\makebox{\kwfont #1}}</td></tr><tr><th id="L39"><a href="#L39">39</a></th><td>\newcommand{\AZ}{\ensuremath{\mathcal{A}_{2}}\xspace}</td></tr><tr><th id="L40"><a href="#L40">40</a></th><td></td></tr><tr><th id="L41"><a href="#L41">41</a></th><td>% --------------------------------- tables --------------------------------------</td></tr><tr><th id="L42"><a href="#L42">42</a></th><td>\newcolumntype{v}[1]{&gt;{\raggedright\hspace{0pt}}p{#1}} % line breaking but align text left (not block)</td></tr><tr><th id="L43"><a href="#L43">43</a></th><td></td></tr><tr><th id="L44"><a href="#L44">44</a></th><td>% --------------------------------- listings --------------------------------------</td></tr><tr><th id="L45"><a href="#L45">45</a></th><td>\lstdefinelanguage{ebnf}[]{}</td></tr><tr><th id="L46"><a href="#L46">46</a></th><td>{morekeywords={},</td></tr><tr><th id="L47"><a href="#L47">47</a></th><td>sensitive=true,</td></tr><tr><th id="L48"><a href="#L48">48</a></th><td>comment=[l]{//},</td></tr><tr><th id="L49"><a href="#L49">49</a></th><td>comment=[s]{(*}{*)},</td></tr><tr><th id="L50"><a href="#L50">50</a></th><td>morestring=[b]',</td></tr><tr><th id="L51"><a href="#L51">51</a></th><td>morestring=[b]",</td></tr><tr><th id="L52"><a href="#L52">52</a></th><td>basicstyle=\scriptsize\changefont{pcr}{m}{n},</td></tr><tr><th id="L53"><a href="#L53">53</a></th><td>stringstyle=\changefont{pcr}{b}{n},</td></tr><tr><th id="L54"><a href="#L54">54</a></th><td>columns = fixed</td></tr><tr><th id="L55"><a href="#L55">55</a></th><td>}</td></tr><tr><th id="L56"><a href="#L56">56</a></th><td>\lstdefinelanguage{Oberon}[]{Oberon-2}%</td></tr><tr><th id="L57"><a href="#L57">57</a></th><td>  {morekeywords={OBJECT,SELF,%</td></tr><tr><th id="L58"><a href="#L58">58</a></th><td>   HUGEINT,% Basic Types</td></tr><tr><th id="L59"><a href="#L59">59</a></th><td>   AWAIT},% Built in functions</td></tr><tr><th id="L60"><a href="#L60">60</a></th><td>   %sensitive=f,%</td></tr><tr><th id="L61"><a href="#L61">61</a></th><td>   %alsoother={},% list here in lower case if keyword some where else wrongly highlighted</td></tr><tr><th id="L62"><a href="#L62">62</a></th><td>    morecomment=[s][\color{red}]{(*!}{!*)}</td></tr><tr><th id="L63"><a href="#L63">63</a></th><td>  }[keywords]%</td></tr><tr><th id="L64"><a href="#L64">64</a></th><td>\lstset{language=Oberon,</td></tr><tr><th id="L65"><a href="#L65">65</a></th><td>basicstyle=\small\progfont,keywordstyle=\kwfont ,identifierstyle=\progfont,</td></tr><tr><th id="L66"><a href="#L66">66</a></th><td>commentstyle=\color{darkgrey}, stringstyle=, showstringspaces=false, %keepspaces=true,</td></tr><tr><th id="L67"><a href="#L67">67</a></th><td>numbers=none, numberstyle=\tiny, stepnumber=1, numbersep=5pt, captionpos=b,</td></tr><tr><th id="L68"><a href="#L68">68</a></th><td>columns=flexible, % flexible, fixed, fullflexible</td></tr><tr><th id="L69"><a href="#L69">69</a></th><td>framerule=1mm,frame=shadowbox, rulesepcolor=\color{blue}, % frame = shadowbox</td></tr><tr><th id="L70"><a href="#L70">70</a></th><td>xleftmargin=2mm,xrightmargin=2mm,</td></tr><tr><th id="L71"><a href="#L71">71</a></th><td>breaklines=true,                                % break long lines</td></tr><tr><th id="L72"><a href="#L72">72</a></th><td>breakatwhitespace=true,                 % break lines only at white space</td></tr><tr><th id="L73"><a href="#L73">73</a></th><td>}</td></tr><tr><th id="L74"><a href="#L74">74</a></th><td>\renewcommand{\lstlistingname}{Fig.}</td></tr><tr><th id="L75"><a href="#L75">75</a></th><td></td></tr><tr><th id="L76"><a href="#L76">76</a></th><td></td></tr><tr><th id="L77"><a href="#L77">77</a></th><td>\begin{document}</td></tr><tr><th id="L78"><a href="#L78">78</a></th><td>\title{\AZ Programming Quickstart Guide}</td></tr><tr><th id="L79"><a href="#L79">79</a></th><td>\author{Felix Friedrich, Ulrike Glavitsch, Florian Negele, Sven Stauber}</td></tr><tr><th id="L80"><a href="#L80">80</a></th><td>\maketitle</td></tr><tr><th id="L81"><a href="#L81">81</a></th><td></td></tr><tr><th id="L82"><a href="#L82">82</a></th><td>This is a brief introduction to the programming language Active Oberon and the operating system \AZ. This introduction does neither replace a language report nor is it an introduction to programming. It rather should provide quick access to the \AZ system by ways of comments and examples. It has been prepared for the Operating System Course, Spring Semester 2009, at ETH Zurich as accompanying material to the practical exercises.</td></tr><tr><th id="L83"><a href="#L83">83</a></th><td></td></tr><tr><th id="L84"><a href="#L84">84</a></th><td>\tableofcontents</td></tr><tr><th id="L85"><a href="#L85">85</a></th><td></td></tr><tr><th id="L86"><a href="#L86">86</a></th><td>\section{The \AZ Operating System}\label{section:TheOperatingSystemA2}</td></tr><tr><th id="L87"><a href="#L87">87</a></th><td>\AZ is a modern, multi-processor operating system in the tradition of the ETH operating systems Medos, Oberon and Aos. It is written in Active Oberon with only very few exceptions: little parts of the kernel and some low-level optimized routines are implemented in assembler. \AZ is composed of light-weight processes that are supported by {\em Active Objects} in the language Active Oberon. Active Oberon is a highly readable, abstract programming language with built-in concurrency support. Its abstraction protects programmers from artificial technical complexities while system-near programming is still possible by ways of a special module named `SYSTEM'.</td></tr><tr><th id="L88"><a href="#L88">88</a></th><td></td></tr><tr><th id="L89"><a href="#L89">89</a></th><td>\subsection{Modules and Commands}\label{section:ModulesAndCommands}</td></tr><tr><th id="L90"><a href="#L90">90</a></th><td>Active Oberon is a modular programming language that is supported by a dynamic loading concept in the operating system \AZ. The role of programs and applications is played by {\em modules}. Instead of loading and executing a `program', {\em modules} are loaded and {\em commands} are executed. Once a module is loaded, it stays loaded until it is explicitly unloaded or until the system goes down. Before we give more details on modules and commands, we show an example of a very simple module.</td></tr><tr><th id="L91"><a href="#L91">91</a></th><td></td></tr><tr><th id="L92"><a href="#L92">92</a></th><td>\begin{lstlisting}[language=Oberon,frame=none,caption=A Simple Oberon Module]</td></tr><tr><th id="L93"><a href="#L93">93</a></th><td>MODULE Hello;</td></tr><tr><th id="L94"><a href="#L94">94</a></th><td></td></tr><tr><th id="L95"><a href="#L95">95</a></th><td>IMPORT Commands, KernelLog;</td></tr><tr><th id="L96"><a href="#L96">96</a></th><td></td></tr><tr><th id="L97"><a href="#L97">97</a></th><td>    (* a command taking a context parameter *)</td></tr><tr><th id="L98"><a href="#L98">98</a></th><td>    PROCEDURE World*(context: Commands.Context);</td></tr><tr><th id="L99"><a href="#L99">99</a></th><td>    BEGIN</td></tr><tr><th id="L100"><a href="#L100">100</a></th><td>        context.out.String("Hello World");</td></tr><tr><th id="L101"><a href="#L101">101</a></th><td>        context.out.Ln</td></tr><tr><th id="L102"><a href="#L102">102</a></th><td>    END World;</td></tr><tr><th id="L103"><a href="#L103">103</a></th><td></td></tr><tr><th id="L104"><a href="#L104">104</a></th><td>    (* a command without parameters *)</td></tr><tr><th id="L105"><a href="#L105">105</a></th><td>    PROCEDURE InnerWorld*;</td></tr><tr><th id="L106"><a href="#L106">106</a></th><td>    BEGIN</td></tr><tr><th id="L107"><a href="#L107">107</a></th><td>        KernelLog.String("Hello Kernel World");</td></tr><tr><th id="L108"><a href="#L108">108</a></th><td>        KernelLog.Ln;</td></tr><tr><th id="L109"><a href="#L109">109</a></th><td>    END InnerWorld;</td></tr><tr><th id="L110"><a href="#L110">110</a></th><td></td></tr><tr><th id="L111"><a href="#L111">111</a></th><td>END Hello.</td></tr><tr><th id="L112"><a href="#L112">112</a></th><td>\end{lstlisting}</td></tr><tr><th id="L113"><a href="#L113">113</a></th><td></td></tr><tr><th id="L114"><a href="#L114">114</a></th><td>Commands are executed by activating a command string of the form \verb+ModuleName.CommandName+ within any text displayed on the screen. In the simple example above, this would be the strings \verb+Hello.World+ and \verb+Hello.InnerWorld+. A command is usually activated by a middle-mouse click or by selecting the command string and using the key-combination \verb|Ctrl+Return|. When a command is activated, the module with name \verb+ModuleName+ is dynamically loaded on demand and the procedure named \verb+CommandName+ in module \verb+ModuleName+ is executed.</td></tr><tr><th id="L115"><a href="#L115">115</a></th><td></td></tr><tr><th id="L116"><a href="#L116">116</a></th><td>Note that a module name has nothing to do with the name of the file that contains the source code of the module. It is pure convention that source code files are usually denominated as \verb+ModuleName.Mod+.</td></tr><tr><th id="L117"><a href="#L117">117</a></th><td></td></tr><tr><th id="L118"><a href="#L118">118</a></th><td>\subsection{Loading and Unloading Modules}\label{section:LoadingAndUnloadingModules}</td></tr><tr><th id="L119"><a href="#L119">119</a></th><td>When a module is compiled, an {\em object file} is generated and is made persistent in a file. It is not immediately loaded.</td></tr><tr><th id="L120"><a href="#L120">120</a></th><td>Basically, a module \verb+M+ is loaded when a command of the form \verb+M.CommandName+ is activated. A module X is also automatically loaded when any module importing X is loaded (cf.~Paragraph~\ref{section:ImportList}).</td></tr><tr><th id="L121"><a href="#L121">121</a></th><td></td></tr><tr><th id="L122"><a href="#L122">122</a></th><td>A module stays loaded until it is unloaded explicitly. Modules can be unloaded with the command</td></tr><tr><th id="L123"><a href="#L123">123</a></th><td>\begin{center}</td></tr><tr><th id="L124"><a href="#L124">124</a></th><td>\verb+SystemTools.Free ModuleName1 ModuleName2 ... ~+</td></tr><tr><th id="L125"><a href="#L125">125</a></th><td>\end{center}</td></tr><tr><th id="L126"><a href="#L126">126</a></th><td>where the tilde `\verb+~+' indicates the end of the list. Note that a module \verb+A+ can only be unloaded if no other currently loaded module imports \verb+A+.</td></tr><tr><th id="L127"><a href="#L127">127</a></th><td></td></tr><tr><th id="L128"><a href="#L128">128</a></th><td>\section{The Language Active Oberon}\label{section:TheLanguageActiveOberon}</td></tr><tr><th id="L129"><a href="#L129">129</a></th><td></td></tr><tr><th id="L130"><a href="#L130">130</a></th><td>\subsection{Module Structure}</td></tr><tr><th id="L131"><a href="#L131">131</a></th><td>A module consists of an import list, constant declarations, type declarations, variable declarations, procedure declarations and a body, all optional. In this Section, we describe these parts.</td></tr><tr><th id="L132"><a href="#L132">132</a></th><td></td></tr><tr><th id="L133"><a href="#L133">133</a></th><td>\subsubsection{Import Section} \label{section:ImportList}</td></tr><tr><th id="L134"><a href="#L134">134</a></th><td>The exported symbols of a module can be made available to other modules. To make the symbols of module \verb+A+ available in module \verb+B+, module \verb+A+ has to be imported in module \verb+B+. A module import graph is a directed graph where cycles are forbidden.\footnote{Cycles in the import graph are detected by the compiler.}</td></tr><tr><th id="L135"><a href="#L135">135</a></th><td></td></tr><tr><th id="L136"><a href="#L136">136</a></th><td>Symbols in one module that are to be used in any other module must be exported. A symbol is exported by suffixing the name with an asterisk `\verb+*+'. It is exported read only by suffixing with a minus symbol `\verb+-+'. We provide a little example of a module \verb+A+ being imported by a module \verb+B+.</td></tr><tr><th id="L137"><a href="#L137">137</a></th><td></td></tr><tr><th id="L138"><a href="#L138">138</a></th><td>\begin{lstlisting}[language=Oberon,frame=none,caption={B imports A}]</td></tr><tr><th id="L139"><a href="#L139">139</a></th><td>MODULE A;</td></tr><tr><th id="L140"><a href="#L140">140</a></th><td>    CONST ExportedConst*=100;</td></tr><tr><th id="L141"><a href="#L141">141</a></th><td>END A.</td></tr><tr><th id="L142"><a href="#L142">142</a></th><td></td></tr><tr><th id="L143"><a href="#L143">143</a></th><td>MODULE B;</td></tr><tr><th id="L144"><a href="#L144">144</a></th><td>    IMPORT A;</td></tr><tr><th id="L145"><a href="#L145">145</a></th><td>    VAR c-: LONGINT;</td></tr><tr><th id="L146"><a href="#L146">146</a></th><td>BEGIN</td></tr><tr><th id="L147"><a href="#L147">147</a></th><td>    c := A.ExportedConst;</td></tr><tr><th id="L148"><a href="#L148">148</a></th><td>END B.</td></tr><tr><th id="L149"><a href="#L149">149</a></th><td>\end{lstlisting}</td></tr><tr><th id="L150"><a href="#L150">150</a></th><td></td></tr><tr><th id="L151"><a href="#L151">151</a></th><td>\subsubsection{Constant Declaration Section}\label{section:ConstantDeclarationSection}</td></tr><tr><th id="L152"><a href="#L152">152</a></th><td>Although static values can be used in expressions, it is possible to associate an identifier with a constant expression, in other words: to {\em declare a constant}. Only values of basic type and strings\footnote{In Active Oberon, strings are array of characters, cf.~Section~\ref{section:Arrays}} can be declared as constants\footnote{There are exceptions: special mathematical arrays can also be declared as constants but this goes beyond the scope of this short reference.}. The following module contains some examples.</td></tr><tr><th id="L153"><a href="#L153">153</a></th><td></td></tr><tr><th id="L154"><a href="#L154">154</a></th><td>\begin{lstlisting}[language=Oberon,frame=none,caption={Declaration and Usage of Constants}]</td></tr><tr><th id="L155"><a href="#L155">155</a></th><td>MODULE Random;</td></tr><tr><th id="L156"><a href="#L156">156</a></th><td></td></tr><tr><th id="L157"><a href="#L157">157</a></th><td>CONST</td></tr><tr><th id="L158"><a href="#L158">158</a></th><td>    (* ------ global constants -------- *)</td></tr><tr><th id="L159"><a href="#L159">159</a></th><td>    Max       = 2147483647;</td></tr><tr><th id="L160"><a href="#L160">160</a></th><td>    Allbits   = 7FFFFFFFH; (* hex number *)</td></tr><tr><th id="L161"><a href="#L161">161</a></th><td></td></tr><tr><th id="L162"><a href="#L162">162</a></th><td>VAR</td></tr><tr><th id="L163"><a href="#L163">163</a></th><td>    (* ------ global variable --------- *)</td></tr><tr><th id="L164"><a href="#L164">164</a></th><td>    z: LONGINT;</td></tr><tr><th id="L165"><a href="#L165">165</a></th><td></td></tr><tr><th id="L166"><a href="#L166">166</a></th><td>    PROCEDURE Rand*(): LONGINT;</td></tr><tr><th id="L167"><a href="#L167">167</a></th><td>    (* constants can also be declared in procedure scope: *)</td></tr><tr><th id="L168"><a href="#L168">168</a></th><td>    CONST A = 16807; Q = 127773; R = 2836;</td></tr><tr><th id="L169"><a href="#L169">169</a></th><td>    VAR t: LONGINT;</td></tr><tr><th id="L170"><a href="#L170">170</a></th><td>    BEGIN</td></tr><tr><th id="L171"><a href="#L171">171</a></th><td>        t := A * (z MOD Q) - R * (z DIV Q);</td></tr><tr><th id="L172"><a href="#L172">172</a></th><td>        IF t &gt; 0 THEN z := t ELSE z := t + Max END;</td></tr><tr><th id="L173"><a href="#L173">173</a></th><td>        RETURN z;</td></tr><tr><th id="L174"><a href="#L174">174</a></th><td>    END Rand;</td></tr><tr><th id="L175"><a href="#L175">175</a></th><td>BEGIN</td></tr><tr><th id="L176"><a href="#L176">176</a></th><td>    z := Allbits;</td></tr><tr><th id="L177"><a href="#L177">177</a></th><td>END Random.</td></tr><tr><th id="L178"><a href="#L178">178</a></th><td>\end{lstlisting}</td></tr><tr><th id="L179"><a href="#L179">179</a></th><td></td></tr><tr><th id="L180"><a href="#L180">180</a></th><td>\subsubsection{Type Declaration Section}\label{section:TypeDeclarationSection}</td></tr><tr><th id="L181"><a href="#L181">181</a></th><td>Type declarations bind an identifier to a type that can be used in variable declarations to name the type of the variables (see section \ref{section:VariableDeclarationSection}). Type declarations are used to provide synonyms for user-defined composite types or existing types such as all predeclared basic types (see sections \ref{section:CompositeTypes} and \ref{section:BasicTypes} respectively). The following example uses a type declaration to assign a new name to a composite record type.</td></tr><tr><th id="L182"><a href="#L182">182</a></th><td></td></tr><tr><th id="L183"><a href="#L183">183</a></th><td>\begin{lstlisting}[language=Oberon,frame=none,caption={Using Type Declarations}]</td></tr><tr><th id="L184"><a href="#L184">184</a></th><td>MODULE TypeDeclarations;</td></tr><tr><th id="L185"><a href="#L185">185</a></th><td></td></tr><tr><th id="L186"><a href="#L186">186</a></th><td>TYPE</td></tr><tr><th id="L187"><a href="#L187">187</a></th><td>    NumberType = REAL;</td></tr><tr><th id="L188"><a href="#L188">188</a></th><td>    ComplexNumber = RECORD re,im: NumberType END;</td></tr><tr><th id="L189"><a href="#L189">189</a></th><td></td></tr><tr><th id="L190"><a href="#L190">190</a></th><td>VAR</td></tr><tr><th id="L191"><a href="#L191">191</a></th><td>    res,a,b: ComplexNumber;</td></tr><tr><th id="L192"><a href="#L192">192</a></th><td></td></tr><tr><th id="L193"><a href="#L193">193</a></th><td>    PROCEDURE Multiply(VAR res: ComplexNumber; x,y: ComplexNumber);</td></tr><tr><th id="L194"><a href="#L194">194</a></th><td>    BEGIN</td></tr><tr><th id="L195"><a href="#L195">195</a></th><td>        res.re := x.re*y.re - x.im*y.im;</td></tr><tr><th id="L196"><a href="#L196">196</a></th><td>        res.im := x.re*y.im + x.im*y.re;</td></tr><tr><th id="L197"><a href="#L197">197</a></th><td>    END Multiply;</td></tr><tr><th id="L198"><a href="#L198">198</a></th><td></td></tr><tr><th id="L199"><a href="#L199">199</a></th><td>BEGIN</td></tr><tr><th id="L200"><a href="#L200">200</a></th><td>    (* ... *)</td></tr><tr><th id="L201"><a href="#L201">201</a></th><td>    Multiply(res,a,b);</td></tr><tr><th id="L202"><a href="#L202">202</a></th><td>    (* ... *)</td></tr><tr><th id="L203"><a href="#L203">203</a></th><td>END TypeDeclarations.</td></tr><tr><th id="L204"><a href="#L204">204</a></th><td>\end{lstlisting}</td></tr><tr><th id="L205"><a href="#L205">205</a></th><td></td></tr><tr><th id="L206"><a href="#L206">206</a></th><td>Note that the call of procedure \verb+Multiply+ with variables \verb+res+, \verb+a+ and \verb+b+ requires that the variables are assignment compatible to the respective parameters. This is guaranteed by using the name of a type declaration which by definition always refers to the same type.</td></tr><tr><th id="L207"><a href="#L207">207</a></th><td></td></tr><tr><th id="L208"><a href="#L208">208</a></th><td>\subsubsection{Variable Declaration Section}\label{section:VariableDeclarationSection}</td></tr><tr><th id="L209"><a href="#L209">209</a></th><td>Variables have to be declared before use in a variable declaration section. A variable declaration consists of an identifier and a type. Variables can be declared globally, in a procedure scope, in an object or in a record scope.</td></tr><tr><th id="L210"><a href="#L210">210</a></th><td></td></tr><tr><th id="L211"><a href="#L211">211</a></th><td>\begin{lstlisting}[language=Oberon,frame=none,caption={Variables and Parameters}]</td></tr><tr><th id="L212"><a href="#L212">212</a></th><td>MODULE Variables;</td></tr><tr><th id="L213"><a href="#L213">213</a></th><td>TYPE</td></tr><tr><th id="L214"><a href="#L214">214</a></th><td>    (* variables in a record *)</td></tr><tr><th id="L215"><a href="#L215">215</a></th><td>    Pair = RECORD x,y: REAL END;</td></tr><tr><th id="L216"><a href="#L216">216</a></th><td>    PairPointer = POINTER TO Pair;</td></tr><tr><th id="L217"><a href="#L217">217</a></th><td>    ExampleObject = OBJECT</td></tr><tr><th id="L218"><a href="#L218">218</a></th><td>        (* object variables *)</td></tr><tr><th id="L219"><a href="#L219">219</a></th><td>        VAR x,y: REAL;</td></tr><tr><th id="L220"><a href="#L220">220</a></th><td>        END ExampleObject;</td></tr><tr><th id="L221"><a href="#L221">221</a></th><td></td></tr><tr><th id="L222"><a href="#L222">222</a></th><td>VAR (* global variables *)</td></tr><tr><th id="L223"><a href="#L223">223</a></th><td>    a: LONGINT;</td></tr><tr><th id="L224"><a href="#L224">224</a></th><td>    b: Pair;</td></tr><tr><th id="L225"><a href="#L225">225</a></th><td>    c: PairPointer;</td></tr><tr><th id="L226"><a href="#L226">226</a></th><td></td></tr><tr><th id="L227"><a href="#L227">227</a></th><td>    PROCEDURE Example;</td></tr><tr><th id="L228"><a href="#L228">228</a></th><td>    (* local variables *)</td></tr><tr><th id="L229"><a href="#L229">229</a></th><td>    VAR a,b: REAL;</td></tr><tr><th id="L230"><a href="#L230">230</a></th><td>    BEGIN</td></tr><tr><th id="L231"><a href="#L231">231</a></th><td>    END Example;</td></tr><tr><th id="L232"><a href="#L232">232</a></th><td></td></tr><tr><th id="L233"><a href="#L233">233</a></th><td>END Variables.</td></tr><tr><th id="L234"><a href="#L234">234</a></th><td>\end{lstlisting}</td></tr><tr><th id="L235"><a href="#L235">235</a></th><td></td></tr><tr><th id="L236"><a href="#L236">236</a></th><td>\subsubsection{Procedure Declaration Section}\label{section:ProcedureDeclarationSection}</td></tr><tr><th id="L237"><a href="#L237">237</a></th><td>Procedures contain the executable code of a module. They can be declared in a module scope, within procedure scopes (`nested procedures') or in object scopes (`methods'). Parameters are special variables that refer to expressions that have been passed to the procedure from its caller. Parameters are declared in the head of the procedure declaration.</td></tr><tr><th id="L238"><a href="#L238">238</a></th><td></td></tr><tr><th id="L239"><a href="#L239">239</a></th><td>Parameters can be {\em value parameters}\footnote{Value parameters are passed over the stack.}, in which case they represent the actual value of an expression being passed to the respective procedure. Or parameters can be {\em variable parameters}\footnote{Variable parameters are references being passed over the stack.}, in which case they stand for the reference of a designator that has been passed to the procedure. The modification of a value parameter within a procedure does only have a temporary effect within the procedure while the modification of a variable parameter implies the modification of the passed variable.</td></tr><tr><th id="L240"><a href="#L240">240</a></th><td></td></tr><tr><th id="L241"><a href="#L241">241</a></th><td>\begin{lstlisting}[language=Oberon,frame=none,caption={Procedures}]</td></tr><tr><th id="L242"><a href="#L242">242</a></th><td>MODULE Procedures;</td></tr><tr><th id="L243"><a href="#L243">243</a></th><td></td></tr><tr><th id="L244"><a href="#L244">244</a></th><td>TYPE</td></tr><tr><th id="L245"><a href="#L245">245</a></th><td>    O = OBJECT</td></tr><tr><th id="L246"><a href="#L246">246</a></th><td></td></tr><tr><th id="L247"><a href="#L247">247</a></th><td>    PROCEDURE Method;</td></tr><tr><th id="L248"><a href="#L248">248</a></th><td>        PROCEDURE NestedProcedure;</td></tr><tr><th id="L249"><a href="#L249">249</a></th><td>        BEGIN</td></tr><tr><th id="L250"><a href="#L250">250</a></th><td>        END NestedProcedure;</td></tr><tr><th id="L251"><a href="#L251">251</a></th><td>    BEGIN</td></tr><tr><th id="L252"><a href="#L252">252</a></th><td>    END Method;</td></tr><tr><th id="L253"><a href="#L253">253</a></th><td></td></tr><tr><th id="L254"><a href="#L254">254</a></th><td>    END O;</td></tr><tr><th id="L255"><a href="#L255">255</a></th><td></td></tr><tr><th id="L256"><a href="#L256">256</a></th><td>    PROCEDURE GlobalProcedure;</td></tr><tr><th id="L257"><a href="#L257">257</a></th><td>        PROCEDURE NestedProcedure;</td></tr><tr><th id="L258"><a href="#L258">258</a></th><td>        BEGIN END NestedProcedure;</td></tr><tr><th id="L259"><a href="#L259">259</a></th><td>    END GlobalProcedure;</td></tr><tr><th id="L260"><a href="#L260">260</a></th><td></td></tr><tr><th id="L261"><a href="#L261">261</a></th><td>    PROCEDURE Square(x: REAL): REAL;</td></tr><tr><th id="L262"><a href="#L262">262</a></th><td>    BEGIN x := x*x; RETURN x</td></tr><tr><th id="L263"><a href="#L263">263</a></th><td>    END Square;</td></tr><tr><th id="L264"><a href="#L264">264</a></th><td></td></tr><tr><th id="L265"><a href="#L265">265</a></th><td>    PROCEDURE Inc(VAR i: INTEGER);</td></tr><tr><th id="L266"><a href="#L266">266</a></th><td>    BEGIN i := i+1</td></tr><tr><th id="L267"><a href="#L267">267</a></th><td>    END Inc;</td></tr><tr><th id="L268"><a href="#L268">268</a></th><td></td></tr><tr><th id="L269"><a href="#L269">269</a></th><td>    PROCEDURE Test*;</td></tr><tr><th id="L270"><a href="#L270">270</a></th><td>    VAR x,sq: REAL; i: INTEGER;</td></tr><tr><th id="L271"><a href="#L271">271</a></th><td>    BEGIN</td></tr><tr><th id="L272"><a href="#L272">272</a></th><td>        x := 10; i := 0;</td></tr><tr><th id="L273"><a href="#L273">273</a></th><td>        sq := Square(x);</td></tr><tr><th id="L274"><a href="#L274">274</a></th><td>        Inc(i);</td></tr><tr><th id="L275"><a href="#L275">275</a></th><td>    END Test;</td></tr><tr><th id="L276"><a href="#L276">276</a></th><td></td></tr><tr><th id="L277"><a href="#L277">277</a></th><td>END Procedures.</td></tr><tr><th id="L278"><a href="#L278">278</a></th><td>\end{lstlisting}</td></tr><tr><th id="L279"><a href="#L279">279</a></th><td></td></tr><tr><th id="L280"><a href="#L280">280</a></th><td>\subsubsection{Body}</td></tr><tr><th id="L281"><a href="#L281">281</a></th><td>A module can provide a body. The body will be executed once after the module has been loaded but prior to any of its commands.</td></tr><tr><th id="L282"><a href="#L282">282</a></th><td>Consider the following example:</td></tr><tr><th id="L283"><a href="#L283">283</a></th><td></td></tr><tr><th id="L284"><a href="#L284">284</a></th><td>\begin{lstlisting}[language=Oberon,frame=none,caption=A simple Oberon Module]</td></tr><tr><th id="L285"><a href="#L285">285</a></th><td>MODULE Hello;</td></tr><tr><th id="L286"><a href="#L286">286</a></th><td></td></tr><tr><th id="L287"><a href="#L287">287</a></th><td>IMPORT KernelLog;</td></tr><tr><th id="L288"><a href="#L288">288</a></th><td></td></tr><tr><th id="L289"><a href="#L289">289</a></th><td>    PROCEDURE World*;</td></tr><tr><th id="L290"><a href="#L290">290</a></th><td>    BEGIN KernelLog.String("Hello World"); KernelLog.Ln;</td></tr><tr><th id="L291"><a href="#L291">291</a></th><td>    END World;</td></tr><tr><th id="L292"><a href="#L292">292</a></th><td></td></tr><tr><th id="L293"><a href="#L293">293</a></th><td>BEGIN</td></tr><tr><th id="L294"><a href="#L294">294</a></th><td>    (* this is a special `procedure': the module body</td></tr><tr><th id="L295"><a href="#L295">295</a></th><td>    it is executed if and only if a module has been freshly loaded *)</td></tr><tr><th id="L296"><a href="#L296">296</a></th><td>    KernelLog.String("Hello has been loaded"); KernelLog.Ln;</td></tr><tr><th id="L297"><a href="#L297">297</a></th><td>END Hello.</td></tr><tr><th id="L298"><a href="#L298">298</a></th><td>\end{lstlisting}</td></tr><tr><th id="L299"><a href="#L299">299</a></th><td></td></tr><tr><th id="L300"><a href="#L300">300</a></th><td>A first call of \verb+Hello.World+ results in the output \pc{Hello has been loaded} and \pc{Hello World} in the kernel log. Each subsequent call will result in an output of \pc{Hello World}, but no further execution of the body. Only if the module has been unloaded, the body is executed again. Note that, consequently, in order to see the effects of a modification and re-compilation of a module it has to be unloaded. (cf.~Section~\ref{section:LoadingAndUnloadingModules}).</td></tr><tr><th id="L301"><a href="#L301">301</a></th><td></td></tr><tr><th id="L302"><a href="#L302">302</a></th><td>\subsection{Basic Types}\label{section:BasicTypes}</td></tr><tr><th id="L303"><a href="#L303">303</a></th><td>There are nine predeclared basic types in Active Oberon. Their names and valid values are shown in table~\ref{table:BasicTypes}.</td></tr><tr><th id="L304"><a href="#L304">304</a></th><td></td></tr><tr><th id="L305"><a href="#L305">305</a></th><td>\begin{table}[h!]</td></tr><tr><th id="L306"><a href="#L306">306</a></th><td>\centering</td></tr><tr><th id="L307"><a href="#L307">307</a></th><td>\begin{tabular}{|l|l|l|}</td></tr><tr><th id="L308"><a href="#L308">308</a></th><td>\hline</td></tr><tr><th id="L309"><a href="#L309">309</a></th><td>Type name &amp; Size &amp; Valid values \\</td></tr><tr><th id="L310"><a href="#L310">310</a></th><td>\hline\hline</td></tr><tr><th id="L311"><a href="#L311">311</a></th><td>\verb+BOOLEAN+ &amp; 1 byte &amp; \verb+TRUE+ or \verb+FALSE+ \\</td></tr><tr><th id="L312"><a href="#L312">312</a></th><td>\hline</td></tr><tr><th id="L313"><a href="#L313">313</a></th><td>\verb+CHAR+ &amp; 1 byte &amp; characters of the extended ASCII set (\verb+0X+ \ldots \verb+0FFX+) \\</td></tr><tr><th id="L314"><a href="#L314">314</a></th><td>\hline</td></tr><tr><th id="L315"><a href="#L315">315</a></th><td>\verb+SHORTINT+ &amp; 1 byte &amp; integers between $-2^{7}$ and $2^{7}-1$ \\</td></tr><tr><th id="L316"><a href="#L316">316</a></th><td>\verb+INTEGER+ &amp; 2 bytes &amp; integers between $-2^{15}$ and $2^{15}-1$ \\</td></tr><tr><th id="L317"><a href="#L317">317</a></th><td>\verb+LONGINT+ &amp; 4 bytes &amp; integers between $-2^{31}$ and $2^{31}-1$ \\</td></tr><tr><th id="L318"><a href="#L318">318</a></th><td>\verb+HUGEINT+ &amp; 8 bytes &amp; integers between $-2^{63}$ and $2^{63}-1$ \\</td></tr><tr><th id="L319"><a href="#L319">319</a></th><td>\hline</td></tr><tr><th id="L320"><a href="#L320">320</a></th><td>\verb+REAL+ &amp; 4 bytes &amp; floating point value between $-3.4028^{38}$ and $+3.4028^{38}$ \\</td></tr><tr><th id="L321"><a href="#L321">321</a></th><td>\verb+LONGREAL+ &amp; 8 bytes &amp; floating point value between $-1.7976^{308}$ and $+1.7976^{308}$ \\</td></tr><tr><th id="L322"><a href="#L322">322</a></th><td>\hline</td></tr><tr><th id="L323"><a href="#L323">323</a></th><td>\verb+SET+ &amp; 4 bytes &amp; any set combination of the integer values between 0 and 31 \\</td></tr><tr><th id="L324"><a href="#L324">324</a></th><td>\hline</td></tr><tr><th id="L325"><a href="#L325">325</a></th><td>\end{tabular}</td></tr><tr><th id="L326"><a href="#L326">326</a></th><td></td></tr><tr><th id="L327"><a href="#L327">327</a></th><td>\caption{Predeclared Basic Types}\label{table:BasicTypes}</td></tr><tr><th id="L328"><a href="#L328">328</a></th><td>\end{table}</td></tr><tr><th id="L329"><a href="#L329">329</a></th><td></td></tr><tr><th id="L330"><a href="#L330">330</a></th><td>\subsubsection{Numeric types} \label{section:HierarchyNumericTypes}</td></tr><tr><th id="L331"><a href="#L331">331</a></th><td>The {\em numeric types} are comprised of the integer and real types and form a set hierarchy</td></tr><tr><th id="L332"><a href="#L332">332</a></th><td></td></tr><tr><th id="L333"><a href="#L333">333</a></th><td>$LONGREAL \supset REAL \supset HUGEINT \supset LONGINT \supset INTEGER \supset SHORTINT$</td></tr><tr><th id="L334"><a href="#L334">334</a></th><td></td></tr><tr><th id="L335"><a href="#L335">335</a></th><td>The range of the larger type includes the ranges of the smaller types. The smaller type is said to be {\em compatible} with the larger one in the sense that it can without danger of loss of leading digits be converted. In assignments and in expansions the conversion of internal representations is automatic.</td></tr><tr><th id="L336"><a href="#L336">336</a></th><td></td></tr><tr><th id="L337"><a href="#L337">337</a></th><td>\subsubsection{BOOLEAN} \label{section:BooleanType}</td></tr><tr><th id="L338"><a href="#L338">338</a></th><td>A Boolean value is one of the {\em logical truth values} which are represented in Active Oberon by the standard identifiers TRUE and FALSE.</td></tr><tr><th id="L339"><a href="#L339">339</a></th><td></td></tr><tr><th id="L340"><a href="#L340">340</a></th><td>\subsubsection{SET} \label{section:SetType}</td></tr><tr><th id="L341"><a href="#L341">341</a></th><td>The values which belong to the type SET are {\em elements of the power set of} $\{0, 1, \ldots, N\}$ where $N$ is equal to MAX(SET), a constant defined by the implementation. It is typically the word length of the computer (or a small multiple of it). In fact, sets are efficiently implemented as bit operations.</td></tr><tr><th id="L342"><a href="#L342">342</a></th><td></td></tr><tr><th id="L343"><a href="#L343">343</a></th><td>Examples of set constants are:</td></tr><tr><th id="L344"><a href="#L344">344</a></th><td>\begin{lstlisting}[language=Oberon,frame=none,caption=Using set constants]</td></tr><tr><th id="L345"><a href="#L345">345</a></th><td>MODULE SetConstants;</td></tr><tr><th id="L346"><a href="#L346">346</a></th><td></td></tr><tr><th id="L347"><a href="#L347">347</a></th><td>CONST</td></tr><tr><th id="L348"><a href="#L348">348</a></th><td>   EmptySet = {};</td></tr><tr><th id="L349"><a href="#L349">349</a></th><td>   SomeElements = {1, 6, 10};</td></tr><tr><th id="L350"><a href="#L350">350</a></th><td>   SomeOthers = {0, 2..4, 8};</td></tr><tr><th id="L351"><a href="#L351">351</a></th><td>END SetConstants.</td></tr><tr><th id="L352"><a href="#L352">352</a></th><td>\end{lstlisting}</td></tr><tr><th id="L353"><a href="#L353">353</a></th><td></td></tr><tr><th id="L354"><a href="#L354">354</a></th><td>where \verb+{}+ denotes the empty set and the expression \verb+2..4+ refers to the elements 2, 3 and 4.</td></tr><tr><th id="L355"><a href="#L355">355</a></th><td></td></tr><tr><th id="L356"><a href="#L356">356</a></th><td>\subsubsection{CHAR}</td></tr><tr><th id="L357"><a href="#L357">357</a></th><td>A major portion of the input and output of computers is in the form of character strings that contain values of type CHAR. The value range of the type CHAR consists of the characters of the roman alphabet and a small set of special symbols used frequently in commerce and mathematics.</td></tr><tr><th id="L358"><a href="#L358">358</a></th><td></td></tr><tr><th id="L359"><a href="#L359">359</a></th><td>The set representing the type CHAR is ordered and each character has a fixed position or {\em ordinal number}. This is reflected in the notation for character constants which may be written as "a" or 61X for the letter a. The first representation denotes the value of the variable of type CHAR, the second its (hexadecimal) {\em ordinal} number.</td></tr><tr><th id="L360"><a href="#L360">360</a></th><td></td></tr><tr><th id="L361"><a href="#L361">361</a></th><td>\subsection{Composite Types}\label{section:CompositeTypes}</td></tr><tr><th id="L362"><a href="#L362">362</a></th><td></td></tr><tr><th id="L363"><a href="#L363">363</a></th><td>In Active Oberon, there are basically three composite types available: Arrays, Records and Objects.</td></tr><tr><th id="L364"><a href="#L364">364</a></th><td></td></tr><tr><th id="L365"><a href="#L365">365</a></th><td>\subsubsection{Arrays}\label{section:Arrays}</td></tr><tr><th id="L366"><a href="#L366">366</a></th><td>Arrays can be declared static, open or dynamic. Static arrays are declared as ARRAY number OF BaseType, where number must be constant. The BaseType can be an array, which allows the declaration of multi-dimensional arrays. Arrays can be declared open only in a parameter section. Dynamic arrays are basically references pointing to an array with lengths that may be provided during runtime.</td></tr><tr><th id="L367"><a href="#L367">367</a></th><td></td></tr><tr><th id="L368"><a href="#L368">368</a></th><td>\begin{lstlisting}[language=Oberon,frame=none,caption=Using arrays]</td></tr><tr><th id="L369"><a href="#L369">369</a></th><td>MODULE Arrays;</td></tr><tr><th id="L370"><a href="#L370">370</a></th><td>VAR</td></tr><tr><th id="L371"><a href="#L371">371</a></th><td>a: ARRAY 32 OF ARRAY 20 OF INTEGER; (* static, two-dimensional *)</td></tr><tr><th id="L372"><a href="#L372">372</a></th><td>b: POINTER TO ARRAY OF INTEGER; (* dynamic, one-dimensional *)</td></tr><tr><th id="L373"><a href="#L373">373</a></th><td></td></tr><tr><th id="L374"><a href="#L374">374</a></th><td>PROCEDURE Print(x: ARRAY OF INTEGER); (* open *)</td></tr><tr><th id="L375"><a href="#L375">375</a></th><td>VAR i: INTEGER;</td></tr><tr><th id="L376"><a href="#L376">376</a></th><td>BEGIN</td></tr><tr><th id="L377"><a href="#L377">377</a></th><td>    i := 0;</td></tr><tr><th id="L378"><a href="#L378">378</a></th><td>    WHILE i&lt;LEN(x) DO</td></tr><tr><th id="L379"><a href="#L379">379</a></th><td>        (* Printout x[i] *)</td></tr><tr><th id="L380"><a href="#L380">380</a></th><td>        INC(i);</td></tr><tr><th id="L381"><a href="#L381">381</a></th><td>    END;</td></tr><tr><th id="L382"><a href="#L382">382</a></th><td>END Print;</td></tr><tr><th id="L383"><a href="#L383">383</a></th><td></td></tr><tr><th id="L384"><a href="#L384">384</a></th><td>PROCEDURE Example;</td></tr><tr><th id="L385"><a href="#L385">385</a></th><td>BEGIN</td></tr><tr><th id="L386"><a href="#L386">386</a></th><td>    NEW(b,100); (* allocate array *)</td></tr><tr><th id="L387"><a href="#L387">387</a></th><td>    (* ... *)</td></tr><tr><th id="L388"><a href="#L388">388</a></th><td>    Print(b^);</td></tr><tr><th id="L389"><a href="#L389">389</a></th><td>END Example;</td></tr><tr><th id="L390"><a href="#L390">390</a></th><td></td></tr><tr><th id="L391"><a href="#L391">391</a></th><td>END Arrays.</td></tr><tr><th id="L392"><a href="#L392">392</a></th><td>\end{lstlisting}</td></tr><tr><th id="L393"><a href="#L393">393</a></th><td></td></tr><tr><th id="L394"><a href="#L394">394</a></th><td>\subsubsection{Records}\label{section:Records}</td></tr><tr><th id="L395"><a href="#L395">395</a></th><td>Records are containers of data. Records are value types and are declared as RECORD (variables) END. Records can also be declared as reference types using POINTER TO. Record fields are referred to via recordName.variableName.</td></tr><tr><th id="L396"><a href="#L396">396</a></th><td>\begin{lstlisting}[language=Oberon,frame=none,caption=Using records]</td></tr><tr><th id="L397"><a href="#L397">397</a></th><td>MODULE Records;</td></tr><tr><th id="L398"><a href="#L398">398</a></th><td>VAR</td></tr><tr><th id="L399"><a href="#L399">399</a></th><td>        a: RECORD x,y: LONGINT END;</td></tr><tr><th id="L400"><a href="#L400">400</a></th><td>        p: POINTER TO RECORD a,b: REAL END;</td></tr><tr><th id="L401"><a href="#L401">401</a></th><td></td></tr><tr><th id="L402"><a href="#L402">402</a></th><td>BEGIN</td></tr><tr><th id="L403"><a href="#L403">403</a></th><td>        NEW(p);</td></tr><tr><th id="L404"><a href="#L404">404</a></th><td>        p.b := a.x;</td></tr><tr><th id="L405"><a href="#L405">405</a></th><td>END Records.</td></tr><tr><th id="L406"><a href="#L406">406</a></th><td>\end{lstlisting}</td></tr><tr><th id="L407"><a href="#L407">407</a></th><td></td></tr><tr><th id="L408"><a href="#L408">408</a></th><td>\subsubsection{Objects}\label{section:Objects}</td></tr><tr><th id="L409"><a href="#L409">409</a></th><td>Objects are basically {\em reference} records that can additionally be equipped with procedures. Procedures in an object are methods: they reside in the object scope and have access to the object's variables. An object can be explicitly referred to in its method using the SELF identifier.</td></tr><tr><th id="L410"><a href="#L410">410</a></th><td>A method prefixed by an ampersand character $\&amp;$ is an \emph{object initializer}. This method is automatically called when an instance of the object is created and processed before the object becomes publicly available. An object may have at most one initializer. If absent, the initializer of the base type is inherited. Initializers can be called like methods.</td></tr><tr><th id="L411"><a href="#L411">411</a></th><td></td></tr><tr><th id="L412"><a href="#L412">412</a></th><td>\begin{lstlisting}[language=Oberon,frame=none,caption=Usage of Objects]</td></tr><tr><th id="L413"><a href="#L413">413</a></th><td>MODULE Objects;</td></tr><tr><th id="L414"><a href="#L414">414</a></th><td>TYPE</td></tr><tr><th id="L415"><a href="#L415">415</a></th><td>MyObject = OBJECT (* class *)</td></tr><tr><th id="L416"><a href="#L416">416</a></th><td>    VAR x,y: REAL;</td></tr><tr><th id="L417"><a href="#L417">417</a></th><td></td></tr><tr><th id="L418"><a href="#L418">418</a></th><td>    PROCEDURE Equals(o: MyObject): BOOLEAN;</td></tr><tr><th id="L419"><a href="#L419">419</a></th><td>    BEGIN</td></tr><tr><th id="L420"><a href="#L420">420</a></th><td>        IF o = SELF THEN RETURN TRUE</td></tr><tr><th id="L421"><a href="#L421">421</a></th><td>        ELSE RETURN (o.x = x) &amp; (o.y = y)</td></tr><tr><th id="L422"><a href="#L422">422</a></th><td>        END;</td></tr><tr><th id="L423"><a href="#L423">423</a></th><td>    END Equals;</td></tr><tr><th id="L424"><a href="#L424">424</a></th><td></td></tr><tr><th id="L425"><a href="#L425">425</a></th><td>    PROCEDURE &amp;Init(x, y : REAL); (* initializer *)</td></tr><tr><th id="L426"><a href="#L426">426</a></th><td>    BEGIN</td></tr><tr><th id="L427"><a href="#L427">427</a></th><td>        SELF.x := x; SELF.y := y;</td></tr><tr><th id="L428"><a href="#L428">428</a></th><td>    END Init;</td></tr><tr><th id="L429"><a href="#L429">429</a></th><td>END MyObject;</td></tr><tr><th id="L430"><a href="#L430">430</a></th><td></td></tr><tr><th id="L431"><a href="#L431">431</a></th><td>VAR p,q: MyObject; (* objects / instances *)</td></tr><tr><th id="L432"><a href="#L432">432</a></th><td></td></tr><tr><th id="L433"><a href="#L433">433</a></th><td>BEGIN</td></tr><tr><th id="L434"><a href="#L434">434</a></th><td>    (* instantiate object p with x and y parameters for initializer *)</td></tr><tr><th id="L435"><a href="#L435">435</a></th><td>    NEW(p, 1.0, 9.99);</td></tr><tr><th id="L436"><a href="#L436">436</a></th><td>    (* ... *)</td></tr><tr><th id="L437"><a href="#L437">437</a></th><td>    IF p.Equals(q) THEN (* ... *)</td></tr><tr><th id="L438"><a href="#L438">438</a></th><td>    END;</td></tr><tr><th id="L439"><a href="#L439">439</a></th><td>END Objects.</td></tr><tr><th id="L440"><a href="#L440">440</a></th><td>\end{lstlisting}</td></tr><tr><th id="L441"><a href="#L441">441</a></th><td></td></tr><tr><th id="L442"><a href="#L442">442</a></th><td>\subsubsection{Inheritance}</td></tr><tr><th id="L443"><a href="#L443">443</a></th><td>Active Oberon is an object oriented language. Inheritance is supported for records and objects. It is possible to extend records and objects and to use type checks, type guards and overriding of methods.</td></tr><tr><th id="L444"><a href="#L444">444</a></th><td>Record and object extension is explicated as in the following example:</td></tr><tr><th id="L445"><a href="#L445">445</a></th><td></td></tr><tr><th id="L446"><a href="#L446">446</a></th><td>\begin{lstlisting}[language=Oberon,frame=none,caption=Type extension of records and objects]</td></tr><tr><th id="L447"><a href="#L447">447</a></th><td>MODULE Extensions;</td></tr><tr><th id="L448"><a href="#L448">448</a></th><td></td></tr><tr><th id="L449"><a href="#L449">449</a></th><td>TYPE</td></tr><tr><th id="L450"><a href="#L450">450</a></th><td>Rectangle = RECORD</td></tr><tr><th id="L451"><a href="#L451">451</a></th><td>    x,y,w,h: INTEGER</td></tr><tr><th id="L452"><a href="#L452">452</a></th><td>END;</td></tr><tr><th id="L453"><a href="#L453">453</a></th><td></td></tr><tr><th id="L454"><a href="#L454">454</a></th><td>FilledRectangle = RECORD(Rectangle)</td></tr><tr><th id="L455"><a href="#L455">455</a></th><td>    color: INTEGER</td></tr><tr><th id="L456"><a href="#L456">456</a></th><td>END;</td></tr><tr><th id="L457"><a href="#L457">457</a></th><td></td></tr><tr><th id="L458"><a href="#L458">458</a></th><td>Window = OBJECT</td></tr><tr><th id="L459"><a href="#L459">459</a></th><td>VAR x,y,w,h: INTEGER;</td></tr><tr><th id="L460"><a href="#L460">460</a></th><td></td></tr><tr><th id="L461"><a href="#L461">461</a></th><td>    PROCEDURE Print;</td></tr><tr><th id="L462"><a href="#L462">462</a></th><td>    BEGIN</td></tr><tr><th id="L463"><a href="#L463">463</a></th><td>        (* draw frame *)</td></tr><tr><th id="L464"><a href="#L464">464</a></th><td>    END Print;</td></tr><tr><th id="L465"><a href="#L465">465</a></th><td>END Window;</td></tr><tr><th id="L466"><a href="#L466">466</a></th><td></td></tr><tr><th id="L467"><a href="#L467">467</a></th><td>FilledWindow = OBJECT (Window)</td></tr><tr><th id="L468"><a href="#L468">468</a></th><td>VAR color: INTEGER;</td></tr><tr><th id="L469"><a href="#L469">469</a></th><td></td></tr><tr><th id="L470"><a href="#L470">470</a></th><td>    PROCEDURE Print; (* overrides Window.Print *)</td></tr><tr><th id="L471"><a href="#L471">471</a></th><td>    BEGIN</td></tr><tr><th id="L472"><a href="#L472">472</a></th><td>        Print^; (* supercall *)</td></tr><tr><th id="L473"><a href="#L473">473</a></th><td>        (* fill *)</td></tr><tr><th id="L474"><a href="#L474">474</a></th><td>    END Print;</td></tr><tr><th id="L475"><a href="#L475">475</a></th><td>END FilledWindow;</td></tr><tr><th id="L476"><a href="#L476">476</a></th><td></td></tr><tr><th id="L477"><a href="#L477">477</a></th><td>END Extensions.</td></tr><tr><th id="L478"><a href="#L478">478</a></th><td>\end{lstlisting}</td></tr><tr><th id="L479"><a href="#L479">479</a></th><td></td></tr><tr><th id="L480"><a href="#L480">480</a></th><td>\subsection{Concurrency Support}</td></tr><tr><th id="L481"><a href="#L481">481</a></th><td>Active Oberon provides built-in concurrency support. Threads are represented as {\em Active Objects} and language constructs for ensuring mutual exclusion and thread synchronization are provided.</td></tr><tr><th id="L482"><a href="#L482">482</a></th><td></td></tr><tr><th id="L483"><a href="#L483">483</a></th><td>\subsubsection{Active Objects}</td></tr><tr><th id="L484"><a href="#L484">484</a></th><td>The declaration of an object type may include an \emph{object body}. The body is the object's activity, to be executed whenever an object instance is allocated after the initializer (if any) completed execution. The object body is annotated with the \emph{ACTIVE} modifier. At allocation, a new process is allocated to execute the body concurrently.</td></tr><tr><th id="L485"><a href="#L485">485</a></th><td>If the ACTIVE modifier is not present, the body is executed synchronously, i.e. NEW returns only after the body has terminated execution.</td></tr><tr><th id="L486"><a href="#L486">486</a></th><td>The active object activity terminates whenever the body execution terminates. As long as the body executes, the object is kept alive (in particular it cannot be garbage collected).</td></tr><tr><th id="L487"><a href="#L487">487</a></th><td></td></tr><tr><th id="L488"><a href="#L488">488</a></th><td>\begin{lstlisting}[language=Oberon,frame=none,caption=Example of an active object]</td></tr><tr><th id="L489"><a href="#L489">489</a></th><td>MODULE Example;</td></tr><tr><th id="L490"><a href="#L490">490</a></th><td>TYPE</td></tr><tr><th id="L491"><a href="#L491">491</a></th><td>   ActiveObject = OBJECT</td></tr><tr><th id="L492"><a href="#L492">492</a></th><td>   BEGIN {ACTIVE}</td></tr><tr><th id="L493"><a href="#L493">493</a></th><td>       (* do some useful work *)</td></tr><tr><th id="L494"><a href="#L494">494</a></th><td>   END ActiveObject;</td></tr><tr><th id="L495"><a href="#L495">495</a></th><td></td></tr><tr><th id="L496"><a href="#L496">496</a></th><td>VAR</td></tr><tr><th id="L497"><a href="#L497">497</a></th><td>   o : ActiveObject;</td></tr><tr><th id="L498"><a href="#L498">498</a></th><td></td></tr><tr><th id="L499"><a href="#L499">499</a></th><td>BEGIN</td></tr><tr><th id="L500"><a href="#L500">500</a></th><td>   (* instantiate active object o *)</td></tr><tr><th id="L501"><a href="#L501">501</a></th><td>   NEW(o);</td></tr><tr><th id="L502"><a href="#L502">502</a></th><td>END Example.</td></tr><tr><th id="L503"><a href="#L503">503</a></th><td>\end{lstlisting}</td></tr><tr><th id="L504"><a href="#L504">504</a></th><td></td></tr><tr><th id="L505"><a href="#L505">505</a></th><td>\subsubsection{Protection}</td></tr><tr><th id="L506"><a href="#L506">506</a></th><td>Like a (procedure-, module- or object-) body, a Statement Block is a sequence of statements delimited by BEGIN and END. It can be used anywhere like a simple statement. An {\em EXCLUSIVE} modifier turns a statement block (or body) into a critical region to protect the statements against concurrent execution. Our protection model is an instance-based monitor: Every object instance is protected and the protection granularity is any statement block inside the object's method, ranging from a single statement to a whole method.</td></tr><tr><th id="L507"><a href="#L507">507</a></th><td></td></tr><tr><th id="L508"><a href="#L508">508</a></th><td>Upon entering an exclusive block, an activity is preempted as long as another activity stands in an exclusive block</td></tr><tr><th id="L509"><a href="#L509">509</a></th><td>of the same object instance. An activity cannot take an object's lock more than once (re-entrance is not allowed).</td></tr><tr><th id="L510"><a href="#L510">510</a></th><td>Modules are considered singleton objects, thus procedures in a module can also be protected. In this case the scope of protection is the whole module.</td></tr><tr><th id="L511"><a href="#L511">511</a></th><td></td></tr><tr><th id="L512"><a href="#L512">512</a></th><td>\begin{lstlisting}[language=Oberon,frame=none,caption=Usage of exclusive blocks]</td></tr><tr><th id="L513"><a href="#L513">513</a></th><td>MODULE Demo;</td></tr><tr><th id="L514"><a href="#L514">514</a></th><td></td></tr><tr><th id="L515"><a href="#L515">515</a></th><td>TYPE</td></tr><tr><th id="L516"><a href="#L516">516</a></th><td>    SomeObject = OBJECT</td></tr><tr><th id="L517"><a href="#L517">517</a></th><td></td></tr><tr><th id="L518"><a href="#L518">518</a></th><td>        PROCEDURE O1;</td></tr><tr><th id="L519"><a href="#L519">519</a></th><td>        BEGIN {EXCLUSIVE}</td></tr><tr><th id="L520"><a href="#L520">520</a></th><td>            (* critical section o1 *)</td></tr><tr><th id="L521"><a href="#L521">521</a></th><td>        END O1;</td></tr><tr><th id="L522"><a href="#L522">522</a></th><td></td></tr><tr><th id="L523"><a href="#L523">523</a></th><td>        PROCEDURE O2;</td></tr><tr><th id="L524"><a href="#L524">524</a></th><td>        BEGIN</td></tr><tr><th id="L525"><a href="#L525">525</a></th><td>            (* non-critical section *)</td></tr><tr><th id="L526"><a href="#L526">526</a></th><td>            BEGIN {EXCLUSIVE} (* critical section o2 *) END;</td></tr><tr><th id="L527"><a href="#L527">527</a></th><td>            (* non-critical section *)</td></tr><tr><th id="L528"><a href="#L528">528</a></th><td>        END O2;</td></tr><tr><th id="L529"><a href="#L529">529</a></th><td></td></tr><tr><th id="L530"><a href="#L530">530</a></th><td>    END SomeObject;</td></tr><tr><th id="L531"><a href="#L531">531</a></th><td></td></tr><tr><th id="L532"><a href="#L532">532</a></th><td>PROCEDURE P1;</td></tr><tr><th id="L533"><a href="#L533">533</a></th><td>BEGIN {EXCLUSIVE}</td></tr><tr><th id="L534"><a href="#L534">534</a></th><td>    (* critical section p1 *)</td></tr><tr><th id="L535"><a href="#L535">535</a></th><td>END P1;</td></tr><tr><th id="L536"><a href="#L536">536</a></th><td></td></tr><tr><th id="L537"><a href="#L537">537</a></th><td>PROCEDURE P2;</td></tr><tr><th id="L538"><a href="#L538">538</a></th><td>BEGIN</td></tr><tr><th id="L539"><a href="#L539">539</a></th><td>    (* non-critical section *)</td></tr><tr><th id="L540"><a href="#L540">540</a></th><td>    BEGIN {EXCLUSIVE} (* critical section p2 *) END;</td></tr><tr><th id="L541"><a href="#L541">541</a></th><td>    (* non-critical section *)</td></tr><tr><th id="L542"><a href="#L542">542</a></th><td>END P2;</td></tr><tr><th id="L543"><a href="#L543">543</a></th><td></td></tr><tr><th id="L544"><a href="#L544">544</a></th><td>END Demo.</td></tr><tr><th id="L545"><a href="#L545">545</a></th><td>\end{lstlisting}</td></tr><tr><th id="L546"><a href="#L546">546</a></th><td></td></tr><tr><th id="L547"><a href="#L547">547</a></th><td>In this example, at most one thread can be in one of the critical sections of the module \emph{p1} or \emph{p2} at any time. For each instance of SomeObject, at most one thread can be in \emph{o1} or \emph{o2} at any time. Note that there is no relation of \emph{p1}, \emph{p2} and \emph{o1}, \emph{o2} in different object instances since the protection is based on \emph{instance-based} monitors.</td></tr><tr><th id="L548"><a href="#L548">548</a></th><td></td></tr><tr><th id="L549"><a href="#L549">549</a></th><td>\subsubsection{Synchronization}</td></tr><tr><th id="L550"><a href="#L550">550</a></th><td>The built-in procedure {\em AWAIT} is used to synchronize an activity with a state of the system. AWAIT can take any boolean condition. The activity is allowed to continue execution only when the condition is true. While the condition is not established, the activity remains suspended. The lock on the protected object is released, as long as the activity remains suspended\footnote{Releasing the lock upon waiting allows other activities to change the state of the object and thus establish the condition}. The activity is resumed if and only if the lock can be taken. The system is responsible for evaluating the conditions and for restarting suspended activities. The conditions inside an object instance are re-evaluated whenever some activity leaves a protected block inside the same object instance.</td></tr><tr><th id="L551"><a href="#L551">551</a></th><td>This implies that changing the state of an object outside a protected block does not imply a re-evaluation of its conditions.</td></tr><tr><th id="L552"><a href="#L552">552</a></th><td>When several activities compete for the same object lock, the activities whose conditions are true are scheduled before those that only want to enter a protected region.</td></tr><tr><th id="L553"><a href="#L553">553</a></th><td></td></tr><tr><th id="L554"><a href="#L554">554</a></th><td>\begin{lstlisting}[language=Oberon,frame=none,caption=Example of object synchronization]</td></tr><tr><th id="L555"><a href="#L555">555</a></th><td>MODULE Example;</td></tr><tr><th id="L556"><a href="#L556">556</a></th><td></td></tr><tr><th id="L557"><a href="#L557">557</a></th><td>TYPE</td></tr><tr><th id="L558"><a href="#L558">558</a></th><td>    Synchronizer = OBJECT</td></tr><tr><th id="L559"><a href="#L559">559</a></th><td>    VAR awake : BOOLEAN;</td></tr><tr><th id="L560"><a href="#L560">560</a></th><td></td></tr><tr><th id="L561"><a href="#L561">561</a></th><td>        PROCEDURE &amp;Init;</td></tr><tr><th id="L562"><a href="#L562">562</a></th><td>        BEGIN</td></tr><tr><th id="L563"><a href="#L563">563</a></th><td>            awake := FALSE;</td></tr><tr><th id="L564"><a href="#L564">564</a></th><td>        END Init;</td></tr><tr><th id="L565"><a href="#L565">565</a></th><td></td></tr><tr><th id="L566"><a href="#L566">566</a></th><td>        PROCEDURE Wait;</td></tr><tr><th id="L567"><a href="#L567">567</a></th><td>        BEGIN {EXCLUSIVE}</td></tr><tr><th id="L568"><a href="#L568">568</a></th><td>           AWAIT(awake); (* suspend caller until awake = TRUE *)</td></tr><tr><th id="L569"><a href="#L569">569</a></th><td>           awake := FALSE;</td></tr><tr><th id="L570"><a href="#L570">570</a></th><td>        END Wait;</td></tr><tr><th id="L571"><a href="#L571">571</a></th><td></td></tr><tr><th id="L572"><a href="#L572">572</a></th><td>        PROCEDURE Wakeup;</td></tr><tr><th id="L573"><a href="#L573">573</a></th><td>        BEGIN {EXCLUSIVE}</td></tr><tr><th id="L574"><a href="#L574">574</a></th><td>           awake := TRUE;</td></tr><tr><th id="L575"><a href="#L575">575</a></th><td>        END Wakeup;</td></tr><tr><th id="L576"><a href="#L576">576</a></th><td></td></tr><tr><th id="L577"><a href="#L577">577</a></th><td>    END Synchronizer;</td></tr><tr><th id="L578"><a href="#L578">578</a></th><td></td></tr><tr><th id="L579"><a href="#L579">579</a></th><td>END Example.</td></tr><tr><th id="L580"><a href="#L580">580</a></th><td>\end{lstlisting}</td></tr><tr><th id="L581"><a href="#L581">581</a></th><td></td></tr><tr><th id="L582"><a href="#L582">582</a></th><td>\subsubsection{Examples}</td></tr><tr><th id="L583"><a href="#L583">583</a></th><td>The following example shows the implementation of a bounded-buffer.</td></tr><tr><th id="L584"><a href="#L584">584</a></th><td></td></tr><tr><th id="L585"><a href="#L585">585</a></th><td>\begin{lstlisting}[language=Oberon,frame=none,caption={Bounded-buffer}]</td></tr><tr><th id="L586"><a href="#L586">586</a></th><td>MODULE Example;</td></tr><tr><th id="L587"><a href="#L587">587</a></th><td></td></tr><tr><th id="L588"><a href="#L588">588</a></th><td>TYPE</td></tr><tr><th id="L589"><a href="#L589">589</a></th><td>  Item* = OBJECT END Item;</td></tr><tr><th id="L590"><a href="#L590">590</a></th><td></td></tr><tr><th id="L591"><a href="#L591">591</a></th><td>  Buffer* = OBJECT</td></tr><tr><th id="L592"><a href="#L592">592</a></th><td>  VAR head, num: LONGINT; buffer: POINTER TO ARRAY OF Item;</td></tr><tr><th id="L593"><a href="#L593">593</a></th><td></td></tr><tr><th id="L594"><a href="#L594">594</a></th><td>    PROCEDURE Append*(x: Item);</td></tr><tr><th id="L595"><a href="#L595">595</a></th><td>    BEGIN {EXCLUSIVE}</td></tr><tr><th id="L596"><a href="#L596">596</a></th><td>      AWAIT(num # LEN(buffer));</td></tr><tr><th id="L597"><a href="#L597">597</a></th><td>      buffer[(head+num) MOD LEN(buffer)] := x;</td></tr><tr><th id="L598"><a href="#L598">598</a></th><td>      INC(num)</td></tr><tr><th id="L599"><a href="#L599">599</a></th><td>    END Append;</td></tr><tr><th id="L600"><a href="#L600">600</a></th><td></td></tr><tr><th id="L601"><a href="#L601">601</a></th><td>    PROCEDURE Remove*(): Item;</td></tr><tr><th id="L602"><a href="#L602">602</a></th><td>    VAR x: Item;</td></tr><tr><th id="L603"><a href="#L603">603</a></th><td>    BEGIN {EXCLUSIVE}</td></tr><tr><th id="L604"><a href="#L604">604</a></th><td>      AWAIT(num # 0);</td></tr><tr><th id="L605"><a href="#L605">605</a></th><td>      x := buffer[head];</td></tr><tr><th id="L606"><a href="#L606">606</a></th><td>      head := (head+1) MOD LEN(buffer);</td></tr><tr><th id="L607"><a href="#L607">607</a></th><td>      DEC(num);</td></tr><tr><th id="L608"><a href="#L608">608</a></th><td>      RETURN x</td></tr><tr><th id="L609"><a href="#L609">609</a></th><td>    END Remove;</td></tr><tr><th id="L610"><a href="#L610">610</a></th><td></td></tr><tr><th id="L611"><a href="#L611">611</a></th><td>    PROCEDURE &amp;Init*(n: LONGINT);</td></tr><tr><th id="L612"><a href="#L612">612</a></th><td>    BEGIN</td></tr><tr><th id="L613"><a href="#L613">613</a></th><td>      head := 0; num := 0; NEW(buffer, n)</td></tr><tr><th id="L614"><a href="#L614">614</a></th><td>    END Init;</td></tr><tr><th id="L615"><a href="#L615">615</a></th><td>  END Buffer;</td></tr><tr><th id="L616"><a href="#L616">616</a></th><td></td></tr><tr><th id="L617"><a href="#L617">617</a></th><td>END Example.</td></tr><tr><th id="L618"><a href="#L618">618</a></th><td>\end{lstlisting}</td></tr><tr><th id="L619"><a href="#L619">619</a></th><td></td></tr><tr><th id="L620"><a href="#L620">620</a></th><td>\section{Application Programming Interfaces}</td></tr><tr><th id="L621"><a href="#L621">621</a></th><td>This section comprises a brief overview of often used application programming interfaces.</td></tr><tr><th id="L622"><a href="#L622">622</a></th><td></td></tr><tr><th id="L623"><a href="#L623">623</a></th><td>\subsection{Streams}</td></tr><tr><th id="L624"><a href="#L624">624</a></th><td>Streams provide an abstraction for easily accessing various resources that can be accessed byte-wise. Streams can be opened on files, network connections, serial port connections, strings, memory and many other resources.</td></tr><tr><th id="L625"><a href="#L625">625</a></th><td>Streams are unidirectional, i.e.\ it is possible to either read from a resource (\emph{Readers}) or write to a resource (\emph{Writers}). Readers maintain an input buffer and writers maintain an output buffer that has to be flushed explicitly by the programmer.</td></tr><tr><th id="L626"><a href="#L626">626</a></th><td>Streams maintain an internal position that is updated automatically whenever a read or write operation is performed. Streams may support random access, depending on the underlying resource.</td></tr><tr><th id="L627"><a href="#L627">627</a></th><td></td></tr><tr><th id="L628"><a href="#L628">628</a></th><td>\begin{lstlisting}[language=Oberon,frame=none,caption={Simplified Reader and Writer Interface}]</td></tr><tr><th id="L629"><a href="#L629">629</a></th><td>MODULE Streams;</td></tr><tr><th id="L630"><a href="#L630">630</a></th><td></td></tr><tr><th id="L631"><a href="#L631">631</a></th><td>(** A reader buffers input received from a Receiver.</td></tr><tr><th id="L632"><a href="#L632">632</a></th><td>    Must not be shared between processes. *)</td></tr><tr><th id="L633"><a href="#L633">633</a></th><td>Reader* = OBJECT</td></tr><tr><th id="L634"><a href="#L634">634</a></th><td></td></tr><tr><th id="L635"><a href="#L635">635</a></th><td>  (** result of last input operation *)</td></tr><tr><th id="L636"><a href="#L636">636</a></th><td>  res*: LONGINT;</td></tr><tr><th id="L637"><a href="#L637">637</a></th><td></td></tr><tr><th id="L638"><a href="#L638">638</a></th><td>  (** Current position. *)</td></tr><tr><th id="L639"><a href="#L639">639</a></th><td>  PROCEDURE Pos*( ): LONGINT;</td></tr><tr><th id="L640"><a href="#L640">640</a></th><td></td></tr><tr><th id="L641"><a href="#L641">641</a></th><td>  (** Returns TRUE if this stream supports random access *)</td></tr><tr><th id="L642"><a href="#L642">642</a></th><td>  PROCEDURE CanSetPos*( ): BOOLEAN;</td></tr><tr><th id="L643"><a href="#L643">643</a></th><td></td></tr><tr><th id="L644"><a href="#L644">644</a></th><td>  (** Set position to &lt;pos&gt; (only if resource supports random access) *)</td></tr><tr><th id="L645"><a href="#L645">645</a></th><td>  PROCEDURE SetPos*( pos: LONGINT );</td></tr><tr><th id="L646"><a href="#L646">646</a></th><td></td></tr><tr><th id="L647"><a href="#L647">647</a></th><td>  (** Return number of bytes currently available in input buffer. *)</td></tr><tr><th id="L648"><a href="#L648">648</a></th><td>  PROCEDURE Available*( ): LONGINT;</td></tr><tr><th id="L649"><a href="#L649">649</a></th><td></td></tr><tr><th id="L650"><a href="#L650">650</a></th><td>  (** Read one byte. *)</td></tr><tr><th id="L651"><a href="#L651">651</a></th><td>  PROCEDURE Char*( VAR x: CHAR );</td></tr><tr><th id="L652"><a href="#L652">652</a></th><td></td></tr><tr><th id="L653"><a href="#L653">653</a></th><td>  (** Read one byte but leave the byte in the input buffer. *)</td></tr><tr><th id="L654"><a href="#L654">654</a></th><td>  PROCEDURE Peek*( ): CHAR;</td></tr><tr><th id="L655"><a href="#L655">655</a></th><td></td></tr><tr><th id="L656"><a href="#L656">656</a></th><td>  (** Read size bytes into x, starting at ofs.</td></tr><tr><th id="L657"><a href="#L657">657</a></th><td>      The len parameter returns the number of bytes that were actually read. *)</td></tr><tr><th id="L658"><a href="#L658">658</a></th><td>  PROCEDURE Bytes*( VAR x: ARRAY OF CHAR;  ofs, size: LONGINT;  VAR len: LONGINT );</td></tr><tr><th id="L659"><a href="#L659">659</a></th><td></td></tr><tr><th id="L660"><a href="#L660">660</a></th><td>  (** Skip n bytes on the reader. *)</td></tr><tr><th id="L661"><a href="#L661">661</a></th><td>  PROCEDURE SkipBytes*( n: LONGINT );</td></tr><tr><th id="L662"><a href="#L662">662</a></th><td></td></tr><tr><th id="L663"><a href="#L663">663</a></th><td>  (** -- Read formatted data (uses Peek for one character lookahead) -- *)</td></tr><tr><th id="L664"><a href="#L664">664</a></th><td></td></tr><tr><th id="L665"><a href="#L665">665</a></th><td>  (** Read an integer value in decimal or hexadecimal.</td></tr><tr><th id="L666"><a href="#L666">666</a></th><td>      If hex = TRUE, recognize the "H" postfix for hexadecimal numbers. *)</td></tr><tr><th id="L667"><a href="#L667">667</a></th><td>  PROCEDURE Int*( VAR x: LONGINT;  hex: BOOLEAN );</td></tr><tr><th id="L668"><a href="#L668">668</a></th><td></td></tr><tr><th id="L669"><a href="#L669">669</a></th><td>  (** Read all characters until the end of the line (inclusive).</td></tr><tr><th id="L670"><a href="#L670">670</a></th><td>      If the input string is larger than x, read the full string and</td></tr><tr><th id="L671"><a href="#L671">671</a></th><td>      assign the truncated 0X-terminated value to x. *)</td></tr><tr><th id="L672"><a href="#L672">672</a></th><td>  PROCEDURE Ln*( VAR x: ARRAY OF CHAR );</td></tr><tr><th id="L673"><a href="#L673">673</a></th><td></td></tr><tr><th id="L674"><a href="#L674">674</a></th><td>  (** Skip over all characters until the end of the line (inclusive). *)</td></tr><tr><th id="L675"><a href="#L675">675</a></th><td>  PROCEDURE SkipLn*;</td></tr><tr><th id="L676"><a href="#L676">676</a></th><td></td></tr><tr><th id="L677"><a href="#L677">677</a></th><td>  (** Skip over space, TAB and EOLN characters. *)</td></tr><tr><th id="L678"><a href="#L678">678</a></th><td>  PROCEDURE SkipWhitespace*;</td></tr><tr><th id="L679"><a href="#L679">679</a></th><td></td></tr><tr><th id="L680"><a href="#L680">680</a></th><td>  (** Read an optionally "" or '' enquoted string.</td></tr><tr><th id="L681"><a href="#L681">681</a></th><td>      Will not read past the end of a line. *)</td></tr><tr><th id="L682"><a href="#L682">682</a></th><td>  PROCEDURE String*( VAR string: ARRAY OF CHAR );</td></tr><tr><th id="L683"><a href="#L683">683</a></th><td></td></tr><tr><th id="L684"><a href="#L684">684</a></th><td>  (** First skip whitespace, then read string *)</td></tr><tr><th id="L685"><a href="#L685">685</a></th><td>  PROCEDURE GetString*(VAR string : ARRAY OF CHAR);</td></tr><tr><th id="L686"><a href="#L686">686</a></th><td></td></tr><tr><th id="L687"><a href="#L687">687</a></th><td>  (** First skip whitespace, then read integer *)</td></tr><tr><th id="L688"><a href="#L688">688</a></th><td>  PROCEDURE GetInteger*(VAR integer : LONGINT; hex : BOOLEAN);</td></tr><tr><th id="L689"><a href="#L689">689</a></th><td></td></tr><tr><th id="L690"><a href="#L690">690</a></th><td>END Reader;</td></tr><tr><th id="L691"><a href="#L691">691</a></th><td></td></tr><tr><th id="L692"><a href="#L692">692</a></th><td>Writer* = OBJECT</td></tr><tr><th id="L693"><a href="#L693">693</a></th><td></td></tr><tr><th id="L694"><a href="#L694">694</a></th><td>  (** result of last output operation *)</td></tr><tr><th id="L695"><a href="#L695">695</a></th><td>  res*: LONGINT;</td></tr><tr><th id="L696"><a href="#L696">696</a></th><td></td></tr><tr><th id="L697"><a href="#L697">697</a></th><td>  (** Current position. *)</td></tr><tr><th id="L698"><a href="#L698">698</a></th><td>  PROCEDURE Pos*( ): LONGINT;</td></tr><tr><th id="L699"><a href="#L699">699</a></th><td></td></tr><tr><th id="L700"><a href="#L700">700</a></th><td>  (** Returns TRUE if this stream supports random access *)</td></tr><tr><th id="L701"><a href="#L701">701</a></th><td>  PROCEDURE CanSetPos*( ): BOOLEAN;</td></tr><tr><th id="L702"><a href="#L702">702</a></th><td></td></tr><tr><th id="L703"><a href="#L703">703</a></th><td>  (** Set position to &lt;pos&gt; (only if resource supports random access) *)</td></tr><tr><th id="L704"><a href="#L704">704</a></th><td>  PROCEDURE SetPos*( pos: LONGINT );</td></tr><tr><th id="L705"><a href="#L705">705</a></th><td></td></tr><tr><th id="L706"><a href="#L706">706</a></th><td>  (** Flush output buffer *)</td></tr><tr><th id="L707"><a href="#L707">707</a></th><td>  PROCEDURE Update*;</td></tr><tr><th id="L708"><a href="#L708">708</a></th><td></td></tr><tr><th id="L709"><a href="#L709">709</a></th><td>  (** Write one byte. *)</td></tr><tr><th id="L710"><a href="#L710">710</a></th><td>  PROCEDURE Char*( x: CHAR );</td></tr><tr><th id="L711"><a href="#L711">711</a></th><td></td></tr><tr><th id="L712"><a href="#L712">712</a></th><td>  (** Write len bytes from x, starting at ofs. *)</td></tr><tr><th id="L713"><a href="#L713">713</a></th><td>  PROCEDURE Bytes*(CONST x: ARRAY OF CHAR;  ofs, len: LONGINT );</td></tr><tr><th id="L714"><a href="#L714">714</a></th><td></td></tr><tr><th id="L715"><a href="#L715">715</a></th><td>  (** -- Write formatted data -- *)</td></tr><tr><th id="L716"><a href="#L716">716</a></th><td></td></tr><tr><th id="L717"><a href="#L717">717</a></th><td>  (** Write an ASCII end-of-line (CR/LF). *)</td></tr><tr><th id="L718"><a href="#L718">718</a></th><td>  PROCEDURE Ln*;</td></tr><tr><th id="L719"><a href="#L719">719</a></th><td></td></tr><tr><th id="L720"><a href="#L720">720</a></th><td>  (** Write a 0X-terminated string, excluding the 0X terminator. *)</td></tr><tr><th id="L721"><a href="#L721">721</a></th><td>  PROCEDURE String*(CONST x: ARRAY OF CHAR );</td></tr><tr><th id="L722"><a href="#L722">722</a></th><td></td></tr><tr><th id="L723"><a href="#L723">723</a></th><td>  (** Write an integer in decimal</td></tr><tr><th id="L724"><a href="#L724">724</a></th><td>      right-justified in a field of at least w characters. *)</td></tr><tr><th id="L725"><a href="#L725">725</a></th><td>  PROCEDURE Int*( x, w: LONGINT );</td></tr><tr><th id="L726"><a href="#L726">726</a></th><td></td></tr><tr><th id="L727"><a href="#L727">727</a></th><td>  (** Write an integer in hexadecimal</td></tr><tr><th id="L728"><a href="#L728">728</a></th><td>      right-justified in a field of at least ABS(w) characters. *)</td></tr><tr><th id="L729"><a href="#L729">729</a></th><td>  PROCEDURE Hex*(x: HUGEINT; w: LONGINT );</td></tr><tr><th id="L730"><a href="#L730">730</a></th><td></td></tr><tr><th id="L731"><a href="#L731">731</a></th><td>END Writer;</td></tr><tr><th id="L732"><a href="#L732">732</a></th><td></td></tr><tr><th id="L733"><a href="#L733">733</a></th><td>END Streams;</td></tr><tr><th id="L734"><a href="#L734">734</a></th><td>\end{lstlisting}</td></tr><tr><th id="L735"><a href="#L735">735</a></th><td></td></tr><tr><th id="L736"><a href="#L736">736</a></th><td>\subsection{Commands}</td></tr><tr><th id="L737"><a href="#L737">737</a></th><td>Commands are procedures that can be invoked directly by the command interpreter. As has already been indicated in Section~\ref{section:ModulesAndCommands}, a procedure can act as a command if and only if it is exported, if it is declared in the module scope and if it has a command signature:</td></tr><tr><th id="L738"><a href="#L738">738</a></th><td>\begin{lstlisting}[language=Oberon,frame=none,caption={Command Signatures}]</td></tr><tr><th id="L739"><a href="#L739">739</a></th><td>(** Command with no arguments *)</td></tr><tr><th id="L740"><a href="#L740">740</a></th><td>PROCEDURE ProcedureName*;</td></tr><tr><th id="L741"><a href="#L741">741</a></th><td></td></tr><tr><th id="L742"><a href="#L742">742</a></th><td>(** Command with arguments and output stream *)</td></tr><tr><th id="L743"><a href="#L743">743</a></th><td>PROCEDURE ProcedureName*(context : Commands.Context);</td></tr><tr><th id="L744"><a href="#L744">744</a></th><td>\end{lstlisting}</td></tr><tr><th id="L745"><a href="#L745">745</a></th><td></td></tr><tr><th id="L746"><a href="#L746">746</a></th><td>An excerpt of the Commands module interface reads as follows:</td></tr><tr><th id="L747"><a href="#L747">747</a></th><td>\begin{lstlisting}[language=Oberon,frame=none,caption={Command Context}]</td></tr><tr><th id="L748"><a href="#L748">748</a></th><td>MODULE Commands;</td></tr><tr><th id="L749"><a href="#L749">749</a></th><td>TYPE</td></tr><tr><th id="L750"><a href="#L750">750</a></th><td>    Context* = OBJECT</td></tr><tr><th id="L751"><a href="#L751">751</a></th><td>    VAR</td></tr><tr><th id="L752"><a href="#L752">752</a></th><td>        in-, arg- : Streams.Reader;</td></tr><tr><th id="L753"><a href="#L753">753</a></th><td>        out-, error- : Streams.Writer;</td></tr><tr><th id="L754"><a href="#L754">754</a></th><td>        caller- : OBJECT;</td></tr><tr><th id="L755"><a href="#L755">755</a></th><td>    END Context;</td></tr><tr><th id="L756"><a href="#L756">756</a></th><td>END Command;</td></tr><tr><th id="L757"><a href="#L757">757</a></th><td>\end{lstlisting}</td></tr><tr><th id="L758"><a href="#L758">758</a></th><td></td></tr><tr><th id="L759"><a href="#L759">759</a></th><td>Command line arguments can be accessed using the \emph{arg} stream. The stream \emph{in} is the command input stream. For output, the streams \emph{out} and \emph{error} are used.</td></tr><tr><th id="L760"><a href="#L760">760</a></th><td>The caller field optionally contains a reference to an object that is responsible for the command invocation. Note that both output stream buffers (out and error) are flushed automatically by the command interpreter.</td></tr><tr><th id="L761"><a href="#L761">761</a></th><td></td></tr><tr><th id="L762"><a href="#L762">762</a></th><td>\begin{lstlisting}[language=Oberon,frame=none,caption={Command Example}]</td></tr><tr><th id="L763"><a href="#L763">763</a></th><td>MODULE Example;</td></tr><tr><th id="L764"><a href="#L764">764</a></th><td>IMPORT Commands;</td></tr><tr><th id="L765"><a href="#L765">765</a></th><td></td></tr><tr><th id="L766"><a href="#L766">766</a></th><td>  PROCEDURE Add*(context : Commands.Context);</td></tr><tr><th id="L767"><a href="#L767">767</a></th><td>  VAR a, b : LONGINT;</td></tr><tr><th id="L768"><a href="#L768">768</a></th><td>  BEGIN</td></tr><tr><th id="L769"><a href="#L769">769</a></th><td>    context.arg.GetInteger(a, FALSE);</td></tr><tr><th id="L770"><a href="#L770">770</a></th><td>    context.arg.GetInteger(b, FALSE);</td></tr><tr><th id="L771"><a href="#L771">771</a></th><td>    context.out.Int(a, 0); context.out.String(" + "); context.out.Int(b, 0);</td></tr><tr><th id="L772"><a href="#L772">772</a></th><td>    context.out.String(" = "); context.out.Int(a + b, 0);</td></tr><tr><th id="L773"><a href="#L773">773</a></th><td>    context.out.Ln;</td></tr><tr><th id="L774"><a href="#L774">774</a></th><td>  END Add;</td></tr><tr><th id="L775"><a href="#L775">775</a></th><td>END Example.</td></tr><tr><th id="L776"><a href="#L776">776</a></th><td>\end{lstlisting}</td></tr><tr><th id="L777"><a href="#L777">777</a></th><td></td></tr><tr><th id="L778"><a href="#L778">778</a></th><td>After compilation of module Example, the command interpreter is able to process the command</td></tr><tr><th id="L779"><a href="#L779">779</a></th><td>\verb+Example.Add 3 5 ~+.</td></tr><tr><th id="L780"><a href="#L780">780</a></th><td>Note that the tilde character indicates the end of the command line arguments.</td></tr><tr><th id="L781"><a href="#L781">781</a></th><td></td></tr><tr><th id="L782"><a href="#L782">782</a></th><td>\subsection{Files}</td></tr><tr><th id="L783"><a href="#L783">783</a></th><td>Module Files provides both the interface to be implemented by file system drivers and \AZ file API.</td></tr><tr><th id="L784"><a href="#L784">784</a></th><td></td></tr><tr><th id="L785"><a href="#L785">785</a></th><td>The most useful operations are</td></tr><tr><th id="L786"><a href="#L786">786</a></th><td>\begin{lstlisting}[language=Oberon,frame=none,caption={Basic Files API}]</td></tr><tr><th id="L787"><a href="#L787">787</a></th><td>MODULE Files;</td></tr><tr><th id="L788"><a href="#L788">788</a></th><td>TYPE</td></tr><tr><th id="L789"><a href="#L789">789</a></th><td>  File* = OBJECT;</td></tr><tr><th id="L790"><a href="#L790">790</a></th><td></td></tr><tr><th id="L791"><a href="#L791">791</a></th><td>  (** Open file &lt;filename&gt;. Returns NIL if file cannot be opened *)</td></tr><tr><th id="L792"><a href="#L792">792</a></th><td>  Old*(filename : ARRAY OF CHAR) : File;</td></tr><tr><th id="L793"><a href="#L793">793</a></th><td></td></tr><tr><th id="L794"><a href="#L794">794</a></th><td>  (** Create file &lt;filename&gt;. Returns NIL if file cannot be created *)</td></tr><tr><th id="L795"><a href="#L795">795</a></th><td>  New*(filename : ARRAY OF CHAR) : File;</td></tr><tr><th id="L796"><a href="#L796">796</a></th><td></td></tr><tr><th id="L797"><a href="#L797">797</a></th><td>  (** Register a new file (create entry in file system directory) *)</td></tr><tr><th id="L798"><a href="#L798">798</a></th><td>  Register*(f : File);</td></tr><tr><th id="L799"><a href="#L799">799</a></th><td>END Files;</td></tr><tr><th id="L800"><a href="#L800">800</a></th><td>\end{lstlisting}</td></tr><tr><th id="L801"><a href="#L801">801</a></th><td></td></tr><tr><th id="L802"><a href="#L802">802</a></th><td>The actual access to files is achieved by using the low-level file riders or by using streams on a file. We describe both methods in the subsequent sections.</td></tr><tr><th id="L803"><a href="#L803">803</a></th><td>\paragraph{File Interface}</td></tr><tr><th id="L804"><a href="#L804">804</a></th><td>The low-level file interface uses so-called riders as context for accessing files. Multiple riders can be positioned independently on a given file. Essentially, riders are used for tracking the position in a file and store the result of the last operation on the file. As for streams, read and write operations automatically update the current position.</td></tr><tr><th id="L805"><a href="#L805">805</a></th><td></td></tr><tr><th id="L806"><a href="#L806">806</a></th><td>\begin{lstlisting}[language=Oberon,frame=none,caption={Low-level Files API}]</td></tr><tr><th id="L807"><a href="#L807">807</a></th><td>(** A rider points to some location in a file,</td></tr><tr><th id="L808"><a href="#L808">808</a></th><td>    where reading and writing will be done. *)</td></tr><tr><th id="L809"><a href="#L809">809</a></th><td>Rider* = RECORD (** not shareable between multiple processes *)</td></tr><tr><th id="L810"><a href="#L810">810</a></th><td>  (** has end of file been passed *)</td></tr><tr><th id="L811"><a href="#L811">811</a></th><td>  eof*: BOOLEAN;</td></tr><tr><th id="L812"><a href="#L812">812</a></th><td></td></tr><tr><th id="L813"><a href="#L813">813</a></th><td>  (** leftover byte count for ReadBytes/WriteBytes *)</td></tr><tr><th id="L814"><a href="#L814">814</a></th><td>  res*: LONGINT;</td></tr><tr><th id="L815"><a href="#L815">815</a></th><td>END;</td></tr><tr><th id="L816"><a href="#L816">816</a></th><td></td></tr><tr><th id="L817"><a href="#L817">817</a></th><td>File* = OBJECT  (** sharable *)</td></tr><tr><th id="L818"><a href="#L818">818</a></th><td>  (* ... *)</td></tr><tr><th id="L819"><a href="#L819">819</a></th><td></td></tr><tr><th id="L820"><a href="#L820">820</a></th><td>  (** Position a Rider at a certain position in a file.</td></tr><tr><th id="L821"><a href="#L821">821</a></th><td>      Multiple Riders can be positioned at different locations in a file.</td></tr><tr><th id="L822"><a href="#L822">822</a></th><td>      A Rider cannot be positioned beyond the end of a file. *)</td></tr><tr><th id="L823"><a href="#L823">823</a></th><td>  PROCEDURE Set*(VAR r: Rider; pos: LONGINT);</td></tr><tr><th id="L824"><a href="#L824">824</a></th><td></td></tr><tr><th id="L825"><a href="#L825">825</a></th><td>  (** Return the offset of a Rider positioned on a file. *)</td></tr><tr><th id="L826"><a href="#L826">826</a></th><td>  PROCEDURE Pos*(VAR r: Rider): LONGINT;</td></tr><tr><th id="L827"><a href="#L827">827</a></th><td></td></tr><tr><th id="L828"><a href="#L828">828</a></th><td>  (** Read a byte from a file, advancing the Rider one byte further.</td></tr><tr><th id="L829"><a href="#L829">829</a></th><td>      R.eof indicates if the end of the file has been passed. *)</td></tr><tr><th id="L830"><a href="#L830">830</a></th><td>  PROCEDURE Read*(VAR r: Rider; VAR x: CHAR);</td></tr><tr><th id="L831"><a href="#L831">831</a></th><td></td></tr><tr><th id="L832"><a href="#L832">832</a></th><td>  (** Read a sequence of len bytes into the buffer x at offset ofs,</td></tr><tr><th id="L833"><a href="#L833">833</a></th><td>      advancing the Rider. Less bytes will be read when reading over the</td></tr><tr><th id="L834"><a href="#L834">834</a></th><td>      end of the file. r.res indicates the number of unread bytes. *)</td></tr><tr><th id="L835"><a href="#L835">835</a></th><td></td></tr><tr><th id="L836"><a href="#L836">836</a></th><td>  PROCEDURE ReadBytes*(VAR r: Rider; VAR x: ARRAY OF CHAR; ofs, len: LONGINT);</td></tr><tr><th id="L837"><a href="#L837">837</a></th><td></td></tr><tr><th id="L838"><a href="#L838">838</a></th><td>  (** Write a byte into the file at the Rider position,</td></tr><tr><th id="L839"><a href="#L839">839</a></th><td>      advancing the Rider by one. *)</td></tr><tr><th id="L840"><a href="#L840">840</a></th><td>  PROCEDURE Write*(VAR r: Rider; x: CHAR);</td></tr><tr><th id="L841"><a href="#L841">841</a></th><td></td></tr><tr><th id="L842"><a href="#L842">842</a></th><td>  (** Write the buffer x containing len bytes (starting at offset ofs)</td></tr><tr><th id="L843"><a href="#L843">843</a></th><td>      into a file at the Rider position. *)</td></tr><tr><th id="L844"><a href="#L844">844</a></th><td>  PROCEDURE WriteBytes*(VAR r: Rider; CONST x: ARRAY OF CHAR; ofs, len: LONGINT);</td></tr><tr><th id="L845"><a href="#L845">845</a></th><td></td></tr><tr><th id="L846"><a href="#L846">846</a></th><td>  (** Return the current length of a file. *)</td></tr><tr><th id="L847"><a href="#L847">847</a></th><td>  PROCEDURE Length*(): LONGINT;</td></tr><tr><th id="L848"><a href="#L848">848</a></th><td></td></tr><tr><th id="L849"><a href="#L849">849</a></th><td>  (** Flush the changes made to a file from its buffers. *)</td></tr><tr><th id="L850"><a href="#L850">850</a></th><td>  PROCEDURE Update*;</td></tr><tr><th id="L851"><a href="#L851">851</a></th><td></td></tr><tr><th id="L852"><a href="#L852">852</a></th><td>END File;</td></tr><tr><th id="L853"><a href="#L853">853</a></th><td>\end{lstlisting}</td></tr><tr><th id="L854"><a href="#L854">854</a></th><td></td></tr><tr><th id="L855"><a href="#L855">855</a></th><td>\paragraph{Using Streams On Files}</td></tr><tr><th id="L856"><a href="#L856">856</a></th><td></td></tr><tr><th id="L857"><a href="#L857">857</a></th><td>First we display a part of the Files interface:</td></tr><tr><th id="L858"><a href="#L858">858</a></th><td>\begin{lstlisting}[language=Oberon,frame=none,caption={Using Streams On Files}]</td></tr><tr><th id="L859"><a href="#L859">859</a></th><td>MODULE Files;</td></tr><tr><th id="L860"><a href="#L860">860</a></th><td></td></tr><tr><th id="L861"><a href="#L861">861</a></th><td>TYPE</td></tr><tr><th id="L862"><a href="#L862">862</a></th><td>  File* = OBJECT; (* as described in last section *)</td></tr><tr><th id="L863"><a href="#L863">863</a></th><td>  Reader* = OBJECT (Streams.Reader);</td></tr><tr><th id="L864"><a href="#L864">864</a></th><td>  Writer* = OBJECT (Streams.Writer);</td></tr><tr><th id="L865"><a href="#L865">865</a></th><td></td></tr><tr><th id="L866"><a href="#L866">866</a></th><td>  OpenReader*(VAR r: Reader; f : File; position : LONGINT);</td></tr><tr><th id="L867"><a href="#L867">867</a></th><td>  OpenWriter*(VAR w : Writer; f : File; position : LONGINT);</td></tr><tr><th id="L868"><a href="#L868">868</a></th><td>END Files.</td></tr><tr><th id="L869"><a href="#L869">869</a></th><td>\end{lstlisting}</td></tr><tr><th id="L870"><a href="#L870">870</a></th><td></td></tr><tr><th id="L871"><a href="#L871">871</a></th><td>Next we provide an example of how to use streams on files.</td></tr><tr><th id="L872"><a href="#L872">872</a></th><td>\begin{lstlisting}[language=Oberon,frame=none,caption={Example: Create A New File}]</td></tr><tr><th id="L873"><a href="#L873">873</a></th><td>MODULE Example;</td></tr><tr><th id="L874"><a href="#L874">874</a></th><td>IMPORT Commands, Files;</td></tr><tr><th id="L875"><a href="#L875">875</a></th><td></td></tr><tr><th id="L876"><a href="#L876">876</a></th><td>PROCEDURE CreateFile*(context : Commands.Context);</td></tr><tr><th id="L877"><a href="#L877">877</a></th><td>VAR</td></tr><tr><th id="L878"><a href="#L878">878</a></th><td>  filename : Files.FileName;</td></tr><tr><th id="L879"><a href="#L879">879</a></th><td>  file : Files.File; writer : Files.Writer;</td></tr><tr><th id="L880"><a href="#L880">880</a></th><td>  ch : CHAR;</td></tr><tr><th id="L881"><a href="#L881">881</a></th><td>BEGIN</td></tr><tr><th id="L882"><a href="#L882">882</a></th><td>   context.arg.GetString(filename);</td></tr><tr><th id="L883"><a href="#L883">883</a></th><td>   file := Files.New(filename);</td></tr><tr><th id="L884"><a href="#L884">884</a></th><td>   IF (file # NIL) THEN</td></tr><tr><th id="L885"><a href="#L885">885</a></th><td>      Files.OpenWriter(writer, file, 0);</td></tr><tr><th id="L886"><a href="#L886">886</a></th><td>      context.arg.Char(ch); (* skip argument delimiter character *)</td></tr><tr><th id="L887"><a href="#L887">887</a></th><td>      REPEAT</td></tr><tr><th id="L888"><a href="#L888">888</a></th><td>         context.arg.Char(ch);</td></tr><tr><th id="L889"><a href="#L889">889</a></th><td>         writer.Char(ch);</td></tr><tr><th id="L890"><a href="#L890">890</a></th><td>      UNTIL (ch = 0X);</td></tr><tr><th id="L891"><a href="#L891">891</a></th><td>      writer.Update;</td></tr><tr><th id="L892"><a href="#L892">892</a></th><td>      Files.Register(file);</td></tr><tr><th id="L893"><a href="#L893">893</a></th><td>   END;</td></tr><tr><th id="L894"><a href="#L894">894</a></th><td>END CreateFile;</td></tr><tr><th id="L895"><a href="#L895">895</a></th><td></td></tr><tr><th id="L896"><a href="#L896">896</a></th><td>END Example.</td></tr><tr><th id="L897"><a href="#L897">897</a></th><td>\end{lstlisting}</td></tr><tr><th id="L898"><a href="#L898">898</a></th><td></td></tr><tr><th id="L899"><a href="#L899">899</a></th><td>In this example, executing the command \verb+Example.CreateFile HelloWorld.txt Hello World ~+ would create (or overwrite) the file ''HelloWorld.txt'' and write the 0X-terminated string ``Hello World '' into it.</td></tr><tr><th id="L900"><a href="#L900">900</a></th><td></td></tr><tr><th id="L901"><a href="#L901">901</a></th><td>\subsection{Strings}</td></tr><tr><th id="L902"><a href="#L902">902</a></th><td>The module Strings provides procedures for ASCII string manipulation.</td></tr><tr><th id="L903"><a href="#L903">903</a></th><td></td></tr><tr><th id="L904"><a href="#L904">904</a></th><td>\begin{lstlisting}[language=Oberon,frame=none,caption={Strings}]</td></tr><tr><th id="L905"><a href="#L905">905</a></th><td>MODULE Strings;</td></tr><tr><th id="L906"><a href="#L906">906</a></th><td></td></tr><tr><th id="L907"><a href="#L907">907</a></th><td>(** returns the length of a string *)</td></tr><tr><th id="L908"><a href="#L908">908</a></th><td>PROCEDURE Length* (CONST string: ARRAY OF CHAR): LONGINT;</td></tr><tr><th id="L909"><a href="#L909">909</a></th><td></td></tr><tr><th id="L910"><a href="#L910">910</a></th><td>(** appends appendix to s: s := s || appendix *)</td></tr><tr><th id="L911"><a href="#L911">911</a></th><td>PROCEDURE Append* (VAR s: ARRAY OF CHAR; CONST appendix: ARRAY OF CHAR);</td></tr><tr><th id="L912"><a href="#L912">912</a></th><td></td></tr><tr><th id="L913"><a href="#L913">913</a></th><td>(** concatenates s1 and s2: s := s1 || s2 *)</td></tr><tr><th id="L914"><a href="#L914">914</a></th><td>PROCEDURE Concat* (CONST s1, s2: ARRAY OF CHAR; VAR s: ARRAY OF CHAR);</td></tr><tr><th id="L915"><a href="#L915">915</a></th><td></td></tr><tr><th id="L916"><a href="#L916">916</a></th><td>(** converts an integer value to a string *)</td></tr><tr><th id="L917"><a href="#L917">917</a></th><td>PROCEDURE IntToStr*(i: LONGINT; VAR s: ARRAY OF CHAR);</td></tr><tr><th id="L918"><a href="#L918">918</a></th><td></td></tr><tr><th id="L919"><a href="#L919">919</a></th><td>(** Simple pattern matching with support for "*" and "?" wildcards</td></tr><tr><th id="L920"><a href="#L920">920</a></th><td>    returns TRUE if name matches mask. *)</td></tr><tr><th id="L921"><a href="#L921">921</a></th><td>PROCEDURE Match*(CONST mask, name: ARRAY OF CHAR): BOOLEAN;</td></tr><tr><th id="L922"><a href="#L922">922</a></th><td></td></tr><tr><th id="L923"><a href="#L923">923</a></th><td>END Strings.</td></tr><tr><th id="L924"><a href="#L924">924</a></th><td>\end{lstlisting}</td></tr><tr><th id="L925"><a href="#L925">925</a></th><td></td></tr><tr><th id="L926"><a href="#L926">926</a></th><td></td></tr><tr><th id="L927"><a href="#L927">927</a></th><td>\appendix</td></tr><tr><th id="L928"><a href="#L928">928</a></th><td>\section{Appendix}</td></tr><tr><th id="L929"><a href="#L929">929</a></th><td></td></tr><tr><th id="L930"><a href="#L930">930</a></th><td>\subsection{Built-in Functions}</td></tr><tr><th id="L931"><a href="#L931">931</a></th><td>There are some built-in procedures and functions in Active Oberon. We give a short overview in the following table. Note that Integer stands for SHORTINT, INTEGER, LONGINT and HUGEINT and Number stands for integers plus REAL and LONGREAL.</td></tr><tr><th id="L932"><a href="#L932">932</a></th><td>\begin{longtable}{|p{2cm}|p{4.3cm}|p{1.95cm}|p{6cm}|}</td></tr><tr><th id="L933"><a href="#L933">933</a></th><td>\hline</td></tr><tr><th id="L934"><a href="#L934">934</a></th><td>Function &amp; Argument Types &amp; Result Type &amp; Description \\</td></tr><tr><th id="L935"><a href="#L935">935</a></th><td>\hline\hline</td></tr><tr><th id="L936"><a href="#L936">936</a></th><td>\endhead</td></tr><tr><th id="L937"><a href="#L937">937</a></th><td>INC(x) &amp; x: Integer &amp;  &amp; increment x by 1 \\</td></tr><tr><th id="L938"><a href="#L938">938</a></th><td>DEC(x) &amp; x: Integer &amp;  &amp; decrement x by 1 \\</td></tr><tr><th id="L939"><a href="#L939">939</a></th><td>INC(x,n) &amp; x: Integer; n: Integer &amp;  &amp; increment x by n \\</td></tr><tr><th id="L940"><a href="#L940">940</a></th><td>DEC(x,n) &amp; x: Integer; n: Integer &amp;  &amp; decrement x by n \\</td></tr><tr><th id="L941"><a href="#L941">941</a></th><td>ASSERT(x) &amp; x: BOOLEAN &amp; &amp; assert trap, if x not true \\</td></tr><tr><th id="L942"><a href="#L942">942</a></th><td>COPY(x,y) &amp; x,y: ARRAY OF CHAR&amp; &amp; 0X-terminated copy of x to y \\</td></tr><tr><th id="L943"><a href="#L943">943</a></th><td>INCL(s,e) &amp; s: SET, e: Integer &amp; &amp; include element e in set s \\</td></tr><tr><th id="L944"><a href="#L944">944</a></th><td>EXCL(s,e) &amp; s: SET, e: Integer &amp; &amp; exclude element e from set s \\</td></tr><tr><th id="L945"><a href="#L945">945</a></th><td>HALT(n) &amp; n: Integer &amp; &amp; generate a trap with number n \\</td></tr><tr><th id="L946"><a href="#L946">946</a></th><td>NEW(x,...) &amp; x: Object or Pointer &amp; &amp; allocate x\\</td></tr><tr><th id="L947"><a href="#L947">947</a></th><td>ABS(x) &amp; x: Number &amp; Number &amp; return absolute value of x\\</td></tr><tr><th id="L948"><a href="#L948">948</a></th><td>ASH(x,y) &amp; x,y: Integer &amp; Integer &amp; return arithmetic shift of x by y bits\\</td></tr><tr><th id="L949"><a href="#L949">949</a></th><td>CAP(x) &amp; x: CHAR &amp; CHAR &amp; return capital letter of x\\</td></tr><tr><th id="L950"><a href="#L950">950</a></th><td>CHR(x) &amp; x: Integer &amp; CHAR &amp; return character with ascii-number x\\</td></tr><tr><th id="L951"><a href="#L951">951</a></th><td>ENTIER(x) &amp; x: REAL or LONGREAL &amp; LONGINT &amp; return largest integer not smaller than x\\</td></tr><tr><th id="L952"><a href="#L952">952</a></th><td>LEN(x) &amp; x: ARRAY OF CHAR &amp; LONGINT &amp; return length of x\\</td></tr><tr><th id="L953"><a href="#L953">953</a></th><td>MAX(t) &amp; t: Number or SET &amp; Number &amp; return maximal number of basic type t\\</td></tr><tr><th id="L954"><a href="#L954">954</a></th><td>MIN(t) &amp; t: Number or SET &amp; Number &amp; return minimal number of basic type t\\</td></tr><tr><th id="L955"><a href="#L955">955</a></th><td>ODD(x) &amp; x: Integer &amp; BOOLEAN &amp; return if x is odd\\</td></tr><tr><th id="L956"><a href="#L956">956</a></th><td>ORD(x) &amp; x: CHAR &amp; LONGINT &amp; return ascii-number of x\\</td></tr><tr><th id="L957"><a href="#L957">957</a></th><td>SHORT(x) &amp; x: Number &amp; Number &amp; number conversion down \\</td></tr><tr><th id="L958"><a href="#L958">958</a></th><td>LONG(x) &amp; x: Number &amp; Number &amp; number conversion up \\</td></tr><tr><th id="L959"><a href="#L959">959</a></th><td>\hline</td></tr><tr><th id="L960"><a href="#L960">960</a></th><td>\end{longtable}</td></tr><tr><th id="L961"><a href="#L961">961</a></th><td>The number conversion routines SHORT and LONG operate with respect to the relations</td></tr><tr><th id="L962"><a href="#L962">962</a></th><td>$$LONGREAL \supset REAL, HUGEINT \supset LONGINT \supset INTEGER \supset SHORTINT.$$</td></tr><tr><th id="L963"><a href="#L963">963</a></th><td></td></tr><tr><th id="L964"><a href="#L964">964</a></th><td>\subsection{The Module SYSTEM}</td></tr><tr><th id="L965"><a href="#L965">965</a></th><td>The (pseudo-)module SYSTEM contains definitions that are necessary to directly refer to resources particular to a given computer and/or implementation. These include facilities for accessing devices that are controlled by the computer, and facilities to override the data type compatibility rules otherwise imposed by the language definition. The functions and procedures exported by this module should be used with care! It is recommended to restrict their use to specific low-level modules. Such modules are inherently non-portable and easily recognized due to the identifier SYSTEM appearing in their import list.</td></tr><tr><th id="L966"><a href="#L966">966</a></th><td>The subsequent definitions are applicable to the \AZ operating system.</td></tr><tr><th id="L967"><a href="#L967">967</a></th><td></td></tr><tr><th id="L968"><a href="#L968">968</a></th><td>\subsubsection{BIT Manipulation}</td></tr><tr><th id="L969"><a href="#L969">969</a></th><td>\begin{longtable}{|p{3cm}|v{3cm}|p{2cm}|p{6cm}|}</td></tr><tr><th id="L970"><a href="#L970">970</a></th><td>\hline</td></tr><tr><th id="L971"><a href="#L971">971</a></th><td>Function &amp; Argument Types &amp; Result Type &amp; Description \\</td></tr><tr><th id="L972"><a href="#L972">972</a></th><td>\hline\hline</td></tr><tr><th id="L973"><a href="#L973">973</a></th><td>\endhead</td></tr><tr><th id="L974"><a href="#L974">974</a></th><td>BIT(adr,n) &amp; adr:~ADDRESS; n:~LONGINT &amp; BOOLEAN &amp; Returns TRUE if bit n at adr is set, FALSE otherwise \\</td></tr><tr><th id="L975"><a href="#L975">975</a></th><td>LSH(x,n) &amp; x:~Integer; n:~LONGINT &amp; Integer &amp; Returns value x logically shifted left n bits (shifts right for n $&lt;$ 0) \\</td></tr><tr><th id="L976"><a href="#L976">976</a></th><td>ROT(x,n) &amp; x:~Integer; n:~LONGINT &amp;  Integer &amp; Returns value x rotated left by  n bits (rotates right for n $&lt;$ 0) \\</td></tr><tr><th id="L977"><a href="#L977">977</a></th><td>\hline</td></tr><tr><th id="L978"><a href="#L978">978</a></th><td>\end{longtable}</td></tr><tr><th id="L979"><a href="#L979">979</a></th><td></td></tr><tr><th id="L980"><a href="#L980">980</a></th><td>\newpage</td></tr><tr><th id="L981"><a href="#L981">981</a></th><td>\subsubsection{SYSTEM Types}</td></tr><tr><th id="L982"><a href="#L982">982</a></th><td>\begin{longtable}{|p{3cm}|p{12cm}|}</td></tr><tr><th id="L983"><a href="#L983">983</a></th><td>\hline</td></tr><tr><th id="L984"><a href="#L984">984</a></th><td>Type &amp; Description \\</td></tr><tr><th id="L985"><a href="#L985">985</a></th><td>\hline\hline</td></tr><tr><th id="L986"><a href="#L986">986</a></th><td>\endhead</td></tr><tr><th id="L987"><a href="#L987">987</a></th><td>ADDRESS &amp; Representation of memory addresses. Currently, this is an alias to either LONGINT or HUGEINT \\</td></tr><tr><th id="L988"><a href="#L988">988</a></th><td>SIZE &amp; Representation of results of arithmetic operations on memory addresses.\\</td></tr><tr><th id="L989"><a href="#L989">989</a></th><td>\hline</td></tr><tr><th id="L990"><a href="#L990">990</a></th><td>BYTE &amp; Representation of a single byte.\\</td></tr><tr><th id="L991"><a href="#L991">991</a></th><td>\hline</td></tr><tr><th id="L992"><a href="#L992">992</a></th><td>\end{longtable}</td></tr><tr><th id="L993"><a href="#L993">993</a></th><td></td></tr><tr><th id="L994"><a href="#L994">994</a></th><td>\subsubsection{Addresses, Sizes and Unsafe Typecasts}</td></tr><tr><th id="L995"><a href="#L995">995</a></th><td>\begin{longtable}{|p{3cm}|p{3cm}|p{2cm}|p{6cm}|}</td></tr><tr><th id="L996"><a href="#L996">996</a></th><td>\hline</td></tr><tr><th id="L997"><a href="#L997">997</a></th><td>Function &amp; Argument Types &amp; Result Type &amp; Description \\</td></tr><tr><th id="L998"><a href="#L998">998</a></th><td>\hline\hline</td></tr><tr><th id="L999"><a href="#L999">999</a></th><td>\endhead</td></tr><tr><th id="L1000"><a href="#L1000">1000</a></th><td>ADR(v) &amp; v: ANY &amp; ADDRESS &amp; Returns the address of v \\</td></tr><tr><th id="L1001"><a href="#L1001">1001</a></th><td>\hline</td></tr><tr><th id="L1002"><a href="#L1002">1002</a></th><td>SIZEOF(v) &amp; v: ANY &amp; SIZE &amp; Returns the size of type v \\</td></tr><tr><th id="L1003"><a href="#L1003">1003</a></th><td>\hline</td></tr><tr><th id="L1004"><a href="#L1004">1004</a></th><td>VAL(T,x) &amp; T: Type; x: ANY &amp; T &amp; Unsafe type cast. Returns x interpreted as type T with no conversion \\</td></tr><tr><th id="L1005"><a href="#L1005">1005</a></th><td>\hline</td></tr><tr><th id="L1006"><a href="#L1006">1006</a></th><td>\end{longtable}</td></tr><tr><th id="L1007"><a href="#L1007">1007</a></th><td></td></tr><tr><th id="L1008"><a href="#L1008">1008</a></th><td>\subsubsection{Direct Memory Access Functions}</td></tr><tr><th id="L1009"><a href="#L1009">1009</a></th><td>\begin{longtable}{|p{3cm}|v{3cm}|p{2cm}|p{6cm}|}</td></tr><tr><th id="L1010"><a href="#L1010">1010</a></th><td>\hline</td></tr><tr><th id="L1011"><a href="#L1011">1011</a></th><td>Function &amp; Argument Types &amp; Result Type &amp; Description \\</td></tr><tr><th id="L1012"><a href="#L1012">1012</a></th><td>\hline\hline</td></tr><tr><th id="L1013"><a href="#L1013">1013</a></th><td>\endhead</td></tr><tr><th id="L1014"><a href="#L1014">1014</a></th><td>PUT(adr,x) &amp; adr:~ADDRESS; x:~Type &amp; &amp; Mem[adr] := x where the size of type x is 8, 16, 32 or 64 bits \\</td></tr><tr><th id="L1015"><a href="#L1015">1015</a></th><td>\hline</td></tr><tr><th id="L1016"><a href="#L1016">1016</a></th><td>PUT8(adr,x) &amp; adr:~ADDRESS; x:~SHORTINT &amp; &amp; Mem[adr] := x \\</td></tr><tr><th id="L1017"><a href="#L1017">1017</a></th><td>PUT16(adr,x) &amp; adr:~ADRESS; x:~INTEGER &amp;&amp; \\</td></tr><tr><th id="L1018"><a href="#L1018">1018</a></th><td>PUT32(adr,x) &amp; adr:~ADDRESS; x:~LONGINT &amp;&amp; \\</td></tr><tr><th id="L1019"><a href="#L1019">1019</a></th><td>PUT64(adr,x) &amp; adr:~ADDRESS; x:~HUGEINT &amp;&amp; \\</td></tr><tr><th id="L1020"><a href="#L1020">1020</a></th><td>\hline</td></tr><tr><th id="L1021"><a href="#L1021">1021</a></th><td>GET(adr,x) &amp; adr:~ADDRESS; VAR x:~Type &amp; &amp; x := Mem[adr] where the size of type x is 8, 16, 32 or 64 bits \\</td></tr><tr><th id="L1022"><a href="#L1022">1022</a></th><td>\hline</td></tr><tr><th id="L1023"><a href="#L1023">1023</a></th><td>GET8(adr) &amp; adr: ADDRESS &amp; SHORTINT &amp; RETURN Mem[adr] \\</td></tr><tr><th id="L1024"><a href="#L1024">1024</a></th><td>GET16(adr) &amp; adr: ADDRESS &amp; INTEGER &amp;\\</td></tr><tr><th id="L1025"><a href="#L1025">1025</a></th><td>GET32(adr) &amp; adr: ADDRESS &amp; LONGINT &amp; \\</td></tr><tr><th id="L1026"><a href="#L1026">1026</a></th><td>GET64(adr) &amp; adr: ADDRESS &amp; HUGEINT &amp; \\</td></tr><tr><th id="L1027"><a href="#L1027">1027</a></th><td>\hline</td></tr><tr><th id="L1028"><a href="#L1028">1028</a></th><td>MOVE(src, dst,n) &amp; dst: ADDRESS; n: SIZE &amp; &amp; Copy "n" bytes from address "src" to address "dst" \\</td></tr><tr><th id="L1029"><a href="#L1029">1029</a></th><td>\hline \end{longtable}</td></tr><tr><th id="L1030"><a href="#L1030">1030</a></th><td></td></tr><tr><th id="L1031"><a href="#L1031">1031</a></th><td>\subsubsection{IA-32 Specific Functions}</td></tr><tr><th id="L1032"><a href="#L1032">1032</a></th><td>\begin{longtable}{|p{3cm}|v{3cm}|p{8cm}|}</td></tr><tr><th id="L1033"><a href="#L1033">1033</a></th><td>\hline</td></tr><tr><th id="L1034"><a href="#L1034">1034</a></th><td>Function &amp; Argument Types &amp; Description \\</td></tr><tr><th id="L1035"><a href="#L1035">1035</a></th><td>\hline\hline</td></tr><tr><th id="L1036"><a href="#L1036">1036</a></th><td>\endhead</td></tr><tr><th id="L1037"><a href="#L1037">1037</a></th><td>PORTIN(adr,x) &amp; adr:~LONGINT; VAR x:~Type &amp; Perform a port input instruction at the specified I/O address. The size of type x must be 8, 16 or 32 bits \\</td></tr><tr><th id="L1038"><a href="#L1038">1038</a></th><td>PORTOUT(adr,x) &amp; adr:~LONGINT; x:~Type &amp; Perform a port output instruction at the specified I/O address. The size of type x must be 8, 16 or 32 bits \\</td></tr><tr><th id="L1039"><a href="#L1039">1039</a></th><td>\hline</td></tr><tr><th id="L1040"><a href="#L1040">1040</a></th><td>CLI() &amp;&amp; Disable interrupts on the current processor \\</td></tr><tr><th id="L1041"><a href="#L1041">1041</a></th><td>STI() &amp;&amp; Enable interrupts on the current processor \\</td></tr><tr><th id="L1042"><a href="#L1042">1042</a></th><td>\hline</td></tr><tr><th id="L1043"><a href="#L1043">1043</a></th><td>GETREG(reg,x) &amp; reg:~LONGINT; VAR x:~Type &amp; x := REGISTER(reg) where the size of type x is 8, 16, 32 or 64 bits depending on the register \\</td></tr><tr><th id="L1044"><a href="#L1044">1044</a></th><td>PUTREG(reg,x) &amp; reg:~LONGINT; x:~Type &amp; REGISTER(reg) := x; where SIZEOF(x) is 8, 16, 32 or 64 bits \\</td></tr><tr><th id="L1045"><a href="#L1045">1045</a></th><td>\hline</td></tr><tr><th id="L1046"><a href="#L1046">1046</a></th><td>EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI &amp;&amp; 32 bit registers \\</td></tr><tr><th id="L1047"><a href="#L1047">1047</a></th><td>AX, CX, DX, BX, SP, BP, SI, DI &amp;&amp; 16 bit registers \\</td></tr><tr><th id="L1048"><a href="#L1048">1048</a></th><td>AL, CL, DL, BL, AH, CH, DH, BH &amp;&amp; 8 bit registers \\</td></tr><tr><th id="L1049"><a href="#L1049">1049</a></th><td>\hline</td></tr><tr><th id="L1050"><a href="#L1050">1050</a></th><td>\end{longtable}</td></tr><tr><th id="L1051"><a href="#L1051">1051</a></th><td></td></tr><tr><th id="L1052"><a href="#L1052">1052</a></th><td></td></tr><tr><th id="L1053"><a href="#L1053">1053</a></th><td>\subsection{Active Oberon EBNF}</td></tr><tr><th id="L1054"><a href="#L1054">1054</a></th><td>We display the syntax of Active Oberon in the Extended Backus-Naur-Form (EBNF). We present productions (syntactic equations) as equations with a single equal sign \verb~=~. On the left hand side of a production stands the defined nonterminal symbol, the right hand side contains the substitution rule and is terminated by a period. Terminal symbols are embraced by single or double quotes (for example \verb~':='~, \verb~"'"~ and \verb~'begin'~). An alternative in a production is denoted by a vertical bar \verb~|~. Brackets \verb~[~ and \verb~]~ denote optionality of the enclosed expression, while braces \verb~{~ and \verb~}~ denote its repetition (possibly 0 times). Additionally, parentheses \verb~(~ and \verb~)~ are used to enclose expressions and thereby control additional precedence.</td></tr><tr><th id="L1055"><a href="#L1055">1055</a></th><td></td></tr><tr><th id="L1056"><a href="#L1056">1056</a></th><td>\begin{lstlisting}[language = EBNF, frame=none,xleftmargin=0mm]</td></tr><tr><th id="L1057"><a href="#L1057">1057</a></th><td>Module               = 'MODULE' Identifier ['IN' Identifier]';'</td></tr><tr><th id="L1058"><a href="#L1058">1058</a></th><td>                        [ImportList] DeclarationSequence [Body]</td></tr><tr><th id="L1059"><a href="#L1059">1059</a></th><td>                       'END' Identifier '.'.</td></tr><tr><th id="L1060"><a href="#L1060">1060</a></th><td></td></tr><tr><th id="L1061"><a href="#L1061">1061</a></th><td>ImportList           = 'IMPORT' Import { ',' Import } ';'.</td></tr><tr><th id="L1062"><a href="#L1062">1062</a></th><td></td></tr><tr><th id="L1063"><a href="#L1063">1063</a></th><td>Import               = Identifier [':=' Identifier] ['IN' Identifier].</td></tr><tr><th id="L1064"><a href="#L1064">1064</a></th><td></td></tr><tr><th id="L1065"><a href="#L1065">1065</a></th><td>DeclarationSequence  =  { 'CONST' [ConstDeclaration] {';' [ConstDeclaration]}</td></tr><tr><th id="L1066"><a href="#L1066">1066</a></th><td>                         |'TYPE'  [TypeDeclaration] {';' [TypeDeclaration]}</td></tr><tr><th id="L1067"><a href="#L1067">1067</a></th><td>                         |'VAR'   [VariableDeclaration] {';' [VariableDeclaration]}</td></tr><tr><th id="L1068"><a href="#L1068">1068</a></th><td>                        }</td></tr><tr><th id="L1069"><a href="#L1069">1069</a></th><td>                        [ProcedureDeclaration | OperatorDeclaration]</td></tr><tr><th id="L1070"><a href="#L1070">1070</a></th><td>                        {';' [ProcedureDeclaration | OperatorDeclaration] }.</td></tr><tr><th id="L1071"><a href="#L1071">1071</a></th><td></td></tr><tr><th id="L1072"><a href="#L1072">1072</a></th><td>ConstDeclaration     = IdentifierDefinition '=' Expression.</td></tr><tr><th id="L1073"><a href="#L1073">1073</a></th><td></td></tr><tr><th id="L1074"><a href="#L1074">1074</a></th><td>TypeDeclaration      = IdentifierDefinition '=' Type.</td></tr><tr><th id="L1075"><a href="#L1075">1075</a></th><td></td></tr><tr><th id="L1076"><a href="#L1076">1076</a></th><td>VariableDeclaration  = VariableNameList ':' Type.</td></tr><tr><th id="L1077"><a href="#L1077">1077</a></th><td></td></tr><tr><th id="L1078"><a href="#L1078">1078</a></th><td>ProcedureDeclaration = 'PROCEDURE' ['&amp;'|'-'|SystemFlag] IdentifierDefinition [FormalParameters]';'</td></tr><tr><th id="L1079"><a href="#L1079">1079</a></th><td>                       DeclarationSequence  [Body] 'END' Identifier.</td></tr><tr><th id="L1080"><a href="#L1080">1080</a></th><td></td></tr><tr><th id="L1081"><a href="#L1081">1081</a></th><td>OperatorDeclaration  = 'OPERATOR' String ['*'|'-'] FormalParameters ';'</td></tr><tr><th id="L1082"><a href="#L1082">1082</a></th><td>                       DeclarationSequence [Body] 'END' String.</td></tr><tr><th id="L1083"><a href="#L1083">1083</a></th><td></td></tr><tr><th id="L1084"><a href="#L1084">1084</a></th><td>SystemFlag           = '{' Identifier '}'.</td></tr><tr><th id="L1085"><a href="#L1085">1085</a></th><td></td></tr><tr><th id="L1086"><a href="#L1086">1086</a></th><td>IdentifierDefinition = Identifier ['*'|'-'].</td></tr><tr><th id="L1087"><a href="#L1087">1087</a></th><td></td></tr><tr><th id="L1088"><a href="#L1088">1088</a></th><td>FormalParameters     = '('[ParameterDeclaration {';' ParameterDeclaration}]')' [':' Type].</td></tr><tr><th id="L1089"><a href="#L1089">1089</a></th><td></td></tr><tr><th id="L1090"><a href="#L1090">1090</a></th><td>ParameterDeclaration = ['VAR'|'CONST'] Identifier {',' Identifier}':' Type.</td></tr><tr><th id="L1091"><a href="#L1091">1091</a></th><td></td></tr><tr><th id="L1092"><a href="#L1092">1092</a></th><td>Type                 = ArrayType | RecordType | PointerType | ObjectType | ProcedureType</td></tr><tr><th id="L1093"><a href="#L1093">1093</a></th><td>                       | QualifiedIdentifier.</td></tr><tr><th id="L1094"><a href="#L1094">1094</a></th><td></td></tr><tr><th id="L1095"><a href="#L1095">1095</a></th><td>ArrayType            = 'ARRAY' [Expression {',' Expression}</td></tr><tr><th id="L1096"><a href="#L1096">1096</a></th><td>                       | '[' MathArraySize {',' MathArraySize} ']' ] 'OF' Type.</td></tr><tr><th id="L1097"><a href="#L1097">1097</a></th><td></td></tr><tr><th id="L1098"><a href="#L1098">1098</a></th><td>MathArraySize        = Expression | '*' | '?'.</td></tr><tr><th id="L1099"><a href="#L1099">1099</a></th><td></td></tr><tr><th id="L1100"><a href="#L1100">1100</a></th><td>RecordType           = 'RECORD' ['(' QualifiedIdentifier ')']</td></tr><tr><th id="L1101"><a href="#L1101">1101</a></th><td>                       [VariableDeclaration {';' VariableDeclaration}] 'END'.</td></tr><tr><th id="L1102"><a href="#L1102">1102</a></th><td></td></tr><tr><th id="L1103"><a href="#L1103">1103</a></th><td>PointerType          = 'POINTER' 'TO' Type.</td></tr><tr><th id="L1104"><a href="#L1104">1104</a></th><td></td></tr><tr><th id="L1105"><a href="#L1105">1105</a></th><td>ObjectType           = 'OBJECT' ['(' QualifiedIdentifier ')'] DeclarationSequence [Body]</td></tr><tr><th id="L1106"><a href="#L1106">1106</a></th><td>                       'END' [Identifier]</td></tr><tr><th id="L1107"><a href="#L1107">1107</a></th><td>                     | 'OBJECT'.</td></tr><tr><th id="L1108"><a href="#L1108">1108</a></th><td></td></tr><tr><th id="L1109"><a href="#L1109">1109</a></th><td>ProcedureType        = 'PROCEDURE' [SystemFlag] [FormalParameters].</td></tr><tr><th id="L1110"><a href="#L1110">1110</a></th><td></td></tr><tr><th id="L1111"><a href="#L1111">1111</a></th><td>Body                 = 'BEGIN' ['{' BlockModifiers '}'] StatementSequence</td></tr><tr><th id="L1112"><a href="#L1112">1112</a></th><td>                       ['FINALLY' StatementSequence]</td></tr><tr><th id="L1113"><a href="#L1113">1113</a></th><td>                     | 'CODE' {any}.</td></tr><tr><th id="L1114"><a href="#L1114">1114</a></th><td></td></tr><tr><th id="L1115"><a href="#L1115">1115</a></th><td>BlockModifiers       = [Identifier ['(' Expression ')'] {',' Identifier ['(' Expression ')'] }]</td></tr><tr><th id="L1116"><a href="#L1116">1116</a></th><td></td></tr><tr><th id="L1117"><a href="#L1117">1117</a></th><td>StatementSequence    = Statement {';' Statement}.</td></tr><tr><th id="L1118"><a href="#L1118">1118</a></th><td></td></tr><tr><th id="L1119"><a href="#L1119">1119</a></th><td>Statement            =</td></tr><tr><th id="L1120"><a href="#L1120">1120</a></th><td>                     [</td></tr><tr><th id="L1121"><a href="#L1121">1121</a></th><td>                     Designator [':=' Expression]</td></tr><tr><th id="L1122"><a href="#L1122">1122</a></th><td>                     | 'IF' Expression 'THEN' StatementSequence</td></tr><tr><th id="L1123"><a href="#L1123">1123</a></th><td>                        {'ELSIF' Expression 'THEN' StatementSequence} 'END'</td></tr><tr><th id="L1124"><a href="#L1124">1124</a></th><td>                     | 'WITH' Identifier ':' QualifiedIdentifier 'DO'</td></tr><tr><th id="L1125"><a href="#L1125">1125</a></th><td>                         StatementSequence 'END'</td></tr><tr><th id="L1126"><a href="#L1126">1126</a></th><td>                     | 'CASE' Expression 'OF' ['|'] Case</td></tr><tr><th id="L1127"><a href="#L1127">1127</a></th><td>                        {'|' Case} ['ELSE' StatementSequence] 'END'</td></tr><tr><th id="L1128"><a href="#L1128">1128</a></th><td>                     | 'WHILE' Expression 'DO' StatementSequence 'END'</td></tr><tr><th id="L1129"><a href="#L1129">1129</a></th><td>                     | 'REPEAT' StatementSequence 'UNTIL' Expression</td></tr><tr><th id="L1130"><a href="#L1130">1130</a></th><td>                     | 'FOR' Identifier ':=' Expression 'TO' Expression ['BY' Expression] 'DO'</td></tr><tr><th id="L1131"><a href="#L1131">1131</a></th><td>                         StatementSequence 'END'</td></tr><tr><th id="L1132"><a href="#L1132">1132</a></th><td>                     | 'LOOP' StatementSequence 'END'</td></tr><tr><th id="L1133"><a href="#L1133">1133</a></th><td>                     | 'EXIT'</td></tr><tr><th id="L1134"><a href="#L1134">1134</a></th><td>                     | 'RETURN' [Expression]</td></tr><tr><th id="L1135"><a href="#L1135">1135</a></th><td>                     | 'AWAIT' Expression</td></tr><tr><th id="L1136"><a href="#L1136">1136</a></th><td>                     | 'BEGIN' StatementBlock 'END'</td></tr><tr><th id="L1137"><a href="#L1137">1137</a></th><td>                     ].</td></tr><tr><th id="L1138"><a href="#L1138">1138</a></th><td></td></tr><tr><th id="L1139"><a href="#L1139">1139</a></th><td>StatementBlock       = ['{' BlockModifiers '}'] StatementSequence.</td></tr><tr><th id="L1140"><a href="#L1140">1140</a></th><td></td></tr><tr><th id="L1141"><a href="#L1141">1141</a></th><td>Case                 = Element {',' Element} ':' StatementSequence.</td></tr><tr><th id="L1142"><a href="#L1142">1142</a></th><td></td></tr><tr><th id="L1143"><a href="#L1143">1143</a></th><td>Expression           = SimpleExpression [RelationOp SimpleExpression].</td></tr><tr><th id="L1144"><a href="#L1144">1144</a></th><td></td></tr><tr><th id="L1145"><a href="#L1145">1145</a></th><td>RelationOp           = '=' | '.=' | '#' | '.#'</td></tr><tr><th id="L1146"><a href="#L1146">1146</a></th><td>                     | '&lt;' | '.&lt;' | '&lt;=' | '.&lt;=' | '&gt;' | '.&gt;' | '&gt;=' | '.&gt;='</td></tr><tr><th id="L1147"><a href="#L1147">1147</a></th><td>                     | 'in' | 'is'</td></tr><tr><th id="L1148"><a href="#L1148">1148</a></th><td></td></tr><tr><th id="L1149"><a href="#L1149">1149</a></th><td>SimpleExpression     = ['+'|'-'] Term {AddOp Term}.</td></tr><tr><th id="L1150"><a href="#L1150">1150</a></th><td></td></tr><tr><th id="L1151"><a href="#L1151">1151</a></th><td>AddOp                = '+' | '-' | 'OR'.</td></tr><tr><th id="L1152"><a href="#L1152">1152</a></th><td></td></tr><tr><th id="L1153"><a href="#L1153">1153</a></th><td>Term                 = Factor {MulOp Factor}.</td></tr><tr><th id="L1154"><a href="#L1154">1154</a></th><td></td></tr><tr><th id="L1155"><a href="#L1155">1155</a></th><td>MulOp                = '*' | '**' | '.*' | '+*' | '/' | './' | 'DIV' | 'MOD' | '&amp;'.</td></tr><tr><th id="L1156"><a href="#L1156">1156</a></th><td></td></tr><tr><th id="L1157"><a href="#L1157">1157</a></th><td>Factor               = Number | Character | String | 'NIL' | 'TRUE' | 'FALSE' | Set</td></tr><tr><th id="L1158"><a href="#L1158">1158</a></th><td>                     | '(' Expression ')' | '~' Factor | Factor '`' | Designator</td></tr><tr><th id="L1159"><a href="#L1159">1159</a></th><td>                     | MathArrayExpression.</td></tr><tr><th id="L1160"><a href="#L1160">1160</a></th><td></td></tr><tr><th id="L1161"><a href="#L1161">1161</a></th><td>MathArrayExpression  = '[' Expression {',' Expression} ']'.</td></tr><tr><th id="L1162"><a href="#L1162">1162</a></th><td></td></tr><tr><th id="L1163"><a href="#L1163">1163</a></th><td>Set                  = '{' [Element {',' Element}] '}'.</td></tr><tr><th id="L1164"><a href="#L1164">1164</a></th><td></td></tr><tr><th id="L1165"><a href="#L1165">1165</a></th><td>Element              = Expression ['..' Expression].</td></tr><tr><th id="L1166"><a href="#L1166">1166</a></th><td></td></tr><tr><th id="L1167"><a href="#L1167">1167</a></th><td>Designator           = ('SELF' | Identifier)</td></tr><tr><th id="L1168"><a href="#L1168">1168</a></th><td>                       {'.' Identifier|'[' RangeList ']' | '('[ExpressionList]')' | '^'}.</td></tr><tr><th id="L1169"><a href="#L1169">1169</a></th><td></td></tr><tr><th id="L1170"><a href="#L1170">1170</a></th><td>RangeList            = Range {',' Range}.</td></tr><tr><th id="L1171"><a href="#L1171">1171</a></th><td></td></tr><tr><th id="L1172"><a href="#L1172">1172</a></th><td>Range                = Expression | [Expression] '..' [Expression] ['by' Expression] | '?' | '*'.</td></tr><tr><th id="L1173"><a href="#L1173">1173</a></th><td></td></tr><tr><th id="L1174"><a href="#L1174">1174</a></th><td>ExpressionList       = Expression {','Expression}.</td></tr><tr><th id="L1175"><a href="#L1175">1175</a></th><td></td></tr><tr><th id="L1176"><a href="#L1176">1176</a></th><td>VariableNameList     = IdentifierDefinition [SystemFlag] {',' IdentifierDefinition [SystemFlag]}.</td></tr><tr><th id="L1177"><a href="#L1177">1177</a></th><td></td></tr><tr><th id="L1178"><a href="#L1178">1178</a></th><td>IdentifierDefinition = Identifier [ '*' | '-' ].</td></tr><tr><th id="L1179"><a href="#L1179">1179</a></th><td></td></tr><tr><th id="L1180"><a href="#L1180">1180</a></th><td>QualifiedIdentifier  = Identifier ['.' Identifier].</td></tr><tr><th id="L1181"><a href="#L1181">1181</a></th><td></td></tr><tr><th id="L1182"><a href="#L1182">1182</a></th><td></td></tr><tr><th id="L1183"><a href="#L1183">1183</a></th><td>Identifier           = Letter {Letter | Digit | '_'}.</td></tr><tr><th id="L1184"><a href="#L1184">1184</a></th><td></td></tr><tr><th id="L1185"><a href="#L1185">1185</a></th><td>Letter               = 'A' | 'B' | .. | 'Z' | 'a' | 'b' | .. | 'z'.</td></tr><tr><th id="L1186"><a href="#L1186">1186</a></th><td></td></tr><tr><th id="L1187"><a href="#L1187">1187</a></th><td>String               = '"' {Character} '"' | "'" {Character} "'".</td></tr><tr><th id="L1188"><a href="#L1188">1188</a></th><td></td></tr><tr><th id="L1189"><a href="#L1189">1189</a></th><td>Number               = Integer | Real.</td></tr><tr><th id="L1190"><a href="#L1190">1190</a></th><td></td></tr><tr><th id="L1191"><a href="#L1191">1191</a></th><td>Integer              = Digit {Digit} | Digit {HexDigit} 'H'.</td></tr><tr><th id="L1192"><a href="#L1192">1192</a></th><td></td></tr><tr><th id="L1193"><a href="#L1193">1193</a></th><td>Real                 = Digit {Digit} '.' {Digit} [ScaleFactor].</td></tr><tr><th id="L1194"><a href="#L1194">1194</a></th><td></td></tr><tr><th id="L1195"><a href="#L1195">1195</a></th><td>ScaleFactor          = ('E' | 'D') ['+' | '-'] digit {digit}.</td></tr><tr><th id="L1196"><a href="#L1196">1196</a></th><td></td></tr><tr><th id="L1197"><a href="#L1197">1197</a></th><td>HexDigit             = Digit | 'A' | 'B' | 'C' | 'D' | 'E' | 'F'.</td></tr><tr><th id="L1198"><a href="#L1198">1198</a></th><td></td></tr><tr><th id="L1199"><a href="#L1199">1199</a></th><td>Digit                = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' .</td></tr><tr><th id="L1200"><a href="#L1200">1200</a></th><td></td></tr><tr><th id="L1201"><a href="#L1201">1201</a></th><td>\end{lstlisting}</td></tr><tr><th id="L1202"><a href="#L1202">1202</a></th><td></td></tr><tr><th id="L1203"><a href="#L1203">1203</a></th><td></td></tr><tr><th id="L1204"><a href="#L1204">1204</a></th><td></td></tr><tr><th id="L1205"><a href="#L1205">1205</a></th><td>%string               = '"' {symbol | escapeSequence} '"'.</td></tr><tr><th id="L1206"><a href="#L1206">1206</a></th><td>%</td></tr><tr><th id="L1207"><a href="#L1207">1207</a></th><td>%character            = "'" (symbol | escapeSequence) "'" | digit {hexDigit} 'X'.</td></tr><tr><th id="L1208"><a href="#L1208">1208</a></th><td>%</td></tr><tr><th id="L1209"><a href="#L1209">1209</a></th><td>%symbol               = (* any character excluding control characters *)</td></tr><tr><th id="L1210"><a href="#L1210">1210</a></th><td>%</td></tr><tr><th id="L1211"><a href="#L1211">1211</a></th><td>%escapeSequence       = '\n' | '\"' | '\\' | "\'"</td></tr><tr><th id="L1212"><a href="#L1212">1212</a></th><td></td></tr><tr><th id="L1213"><a href="#L1213">1213</a></th><td></td></tr><tr><th id="L1214"><a href="#L1214">1214</a></th><td>\end{document}</td></tr><tr><th id="L1215"><a href="#L1215">1215</a></th><td></td></tr></tbody></table>

      </div>
      <div id="help"><strong>Note:</strong> See <a href="/oberonru/wiki/TracBrowser">TracBrowser</a>
        for help on using the repository browser.</div>
      <div id="anydiff">
        <form action="/oberonru/diff" method="get">
          <div class="buttons">
            <input type="hidden" name="new_path" value="/trunk/Docs/ShortCourse/A2QuickStartGuide.tex" />
            <input type="hidden" name="old_path" value="/trunk/Docs/ShortCourse/A2QuickStartGuide.tex" />
            <input type="hidden" name="new_rev" />
            <input type="hidden" name="old_rev" />
            <input type="submit" value="View changes..." title="Select paths and revs for Diff" />
          </div>
        </form>
      </div>
    </div>
    <div id="altlinks">
      <h3>Download in other formats:</h3>
      <ul>
        <li class="first">
          <a rel="nofollow" href="/oberonru/browser/trunk/Docs/ShortCourse/A2QuickStartGuide.tex?format=txt">Plain Text</a>
        </li><li class="last">
          <a rel="nofollow" href="/oberonru/export/229/trunk/Docs/ShortCourse/A2QuickStartGuide.tex">Original Format</a>
        </li>
      </ul>
    </div>
    </div>
    <div id="footer" lang="en" xml:lang="en">
      <a id="tracpowered" href="http://trac.edgewall.org/"><img src="/oberonru/chrome/common/trac_logo_mini.png" height="30" width="107" alt="Trac Powered" /></a>
      <p class="left">
        Powered by <a href="/oberonru/about"><strong>Trac 0.12.3</strong></a><br />
        By <a href="http://www.edgewall.org/">Edgewall Software</a><br />
	Hosted by <a href="http://www.assembla.com">Assembla</a>
      </p>
      <p class="right">Breakout - Social Software to Get Things Done<br /><a title="Free SVN and Trac hosting" href="https://www.assembla.com/">https://www.assembla.com</a></p>
    </div>
    <div id="sitefooter">
    </div>
  </body>
</html>